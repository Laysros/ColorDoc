<h1>8. Normalization </h1></br><h1>1 - Normalize</h1> The mapping of EER diagrams to relations will in all cases be solved in a database which is normalized. In spite of that, we still have to learn about normalization. "Databases are forever, they are all I need to please me, they can stimulate and tease me, they won't leave in the night, I've no fear that they might desert me. " A second reason you need to know how to normalize databases is that the EER diagrams they may have been created from may have gone missing. When you get a database and you look at it for the first time, it's really like a box of chocolate, you never know what's in there. So when you look at a database, it may be beautifully normalized, designed by experts or it may not be normalized and look like it was designed by idiots. Although it looks like that, it could be because some compromises had to be made in the way the database was normalized in order for example to get the database to run faster.

<h1>2 - What's it all about_</h1> So, what is it all about? The idea is that you are given a relation and a set of functional dependencies like these. Here's a relation; it has a number of columns, Email, Interests, SinceAge, et cetera. And there are some dependencies among these columns so-called functional dependencies, we will define them a little bit later. So, for example, it could be that one functional dependency is that given an Email like here that would determine for you what the BirthYear, CurrentCity, and Salary are. So, given the email that would determine birth year, current city and salary could also be that Email and Interest together would determine, so these two together would determine the age since when you had that interest. The big question, is this relation laid out in such a manner that it is easy to enforce the functional dependencies that we want to enforce in the database? An additional question is, how do we normalize the relation or decompose it into smaller relations without losing information and without losing functional dependencies?

<h1>3 - (headshot) The Rules</h1> Here are the rules you must obey when you normalize a relation. First, no redundancy of facts. Second, no cluttering of facts. Third, you must preserve information. And fourth, you must preserve functional dependencies.

<h1>4 - Not a relation</h1> It's really not that difficult to envision how you may end up with a data structure that's not a relation or a data structure that we call a non-first normal form data structure. So, here's an example of it. The idea of this data structure is the following: you have users who have emails, and then each user has a multi-value interest, since age dependency here. So, in this data structure you have user1. User1 has been interested in music since the age of 10, reading since five, tennis since 14. Similarly, user2 has been interested in blogging since 13, meditation since 21, surfing since 19, etc. This is called a multi-value. If you remember the definition of a relation, you will remember that values of attributes are pulled from sets of atomic values. So certainly, music 10, reading five, tennis 14, that is not an atomic value. So, to take a data structure like this which says non-first normal form and create a relation from it. There's one obvious way we could try to do that. So, what if I simply repeat user1 for each one of these rows? What if I repeat this value in each one of the rows? Then I will actually have a relation.

<h1>5 - Relation with problems</h1> So, that's exactly what I've done here. You can see user1 is now repeated three times, and 1985, Seattle, and 27,000 is repeated three times, and it's done to avoid having this be a multi-value, and avoid having this be a multi-value. So this indeed now is a relation, but it is really a relation with many problems in it. So, let us say that in this relation, we want to enforce these three function dependencies that we looked at before. Or an easier way to see what they are is actually to provide a drawing of them like here. So, what we are seeing here is that email will determine current city, birth year, and salary, and the pair of email and interest will determine the since age, and finally we see that birth year will determine salary. So that corresponds to those three functional dependencies. So, with that relation and with these functional dependencies, let's see what kind of trouble we are in.

<h1>6 - Relation with Problems-Redundancy</h1> So, the first problem the relation has, is redundancy. Because we repeat it, all the user1 information; birth year, current city, and salary, in order to avoid the multi value problem you now have redundant information. Redundancy potentially leads to inconsistency. Inconsistency here would appear, if user1 moves say, from Seattle to Atlanta but for whatever reason, you do not get all the Seattle values updated to Atlanta, maybe just the first one. Subsequent to that, users of the database will come in, and they will look for the current city of user1 and in one place it will say Atlanta. In other places it will say Seattle. That means, the database is useless from the point of view of understanding what the current city of the user is.

<h1>7 - Relation with Problems-Insertion anomaly</h1> A second problem is that of insertion anomalies. So, let's say we insert a new user, like user nine into the database, with the user nine information of birth year and current city and salary. Then, if that user right now doesn't have any interest, we would have to insert null values here. Let's say that we would like to insert the information into a database that people that have birth year 1970 make 42,000. Then, we would have to insert null values in all these places if there's currently not someone among the regular users that is born in 1970.

<h1>8 - Relation with Problems-Deletion anomaly</h1> A closely related problem is that of Deletion Anomalies. So, let's say we go in and we want to delete user12 from the database. Then deleting user12 will mean that we lose the information that people born in 74 make 38,000. Why is that? Because there's no other regular user that's born in 74.

<h1>9 - Relation with Problems-Update anomaly</h1> Finally, update anomalies. If you want to update the address for user, too, you're going to have to update it everywhere. If you want to update the salaries that are made by people with birth year 67, you're going to have to remember to do it everywhere.

<h1>10 - Information loss</h1> So, having seen all the problems with the table we started out with, the idea is then to try to decompose that table into multiple tables, so that the function dependencies we talked about can be enforced in those without problems. When we decompose the table into multiple tables, we have to be careful though that we do not lose information. So, look at the regular user table and let us try to decompose it into two tables. When we do the decomposition, we have to include at least one attribute in the two tables, so that we can combine them back together to create the table we operated with initially. The basic idea actually is that this may be the information we would like to look at but the form it's represented in with all the redundancies is all the problems that come from that, we choose instead to operate with two alternative tables. But at any point in time we need to be able to re-combine them and create this look or this view, which is the one we would like to operate with. So, let's look at the example here. So, we take the regular user table and project it first on the columns, email, interest, since age, birth year, and current city. That gives you this table. We then project regular use on current city and salary, that gives you this table. Now also, as I mentioned the idea is that when we now join this table together with this table, we will recreate this table here. Unfortunately, an interesting thing happens in this particular case with this particular decomposition. By combining all the tuples in this relation with all the tuples in this one we will create all of these. But see what happens in addition to that. This San Diego here for user3 will be combined with this San Diego here and 38. Now, let's go look at user3, San Diego 38, that doesn't appear there. So, there are two additional tuples added to the result of the join from here. Also when you look at you user12, San Diego, that user is hooked up to 38, but inadvertently now this San Diego will match this San Diego and 45. So in other words, when we join these two together we actually create three additional tuples in the regular user table that were not there before. This phenomenon is called information loss. You may say, come on that's a bad name for it because I got more information. Well, getting more information that's not reflecting facts of reality is actually information loss, because now you're going to have three additional rows here, and those rows do not reflect facts in reality. Therefore, you have lost your ability to distinguish between the true facts that you started out with and the false facts that were inadvertently added. This is called information loss.

<h1>11 - Dependency Loss</h1> A similar concept called dependency loss happens as follows. So again, look at the regular user table and split it up as we did before in these two alternative tables. Remember, there were a set of functional dependencies that we wanted to enforce on this original table here. When all the information is together in the original table, it is possible to enforce them. However, when we start decomposing the table into additional tables, we may lose the ability to enforce the functional dependencies within a single table. I have two examples of that here. One example is that we had a functional dependency from email to salary, since email and salary do not appear together in any of these two new tables, we can't enforce it within a table. Similarly, birth year determines salary, since the two do not coexist in a table, we cannot enforce them in a table. This is called dependency loss.

<h1>12 - Perfect</h1> So, having seen all of the problems that result from an inappropriate decomposition, let's look at a perfect decomposition. So, in this case, here, we take the regular usual relation and decompose it into three tables. The idea then is that we throw this one away and we operate on these, and when we would like to see this one again, we simply join these together and it appears as if we had continued to operate on the regular user table in a disciplined manner. This decomposition is perfect. Let's analyze it. So, first of all, you saw in the regular user table that there was a lot of redundancy. For example, user1 living in the current city Seattle was repeated three times. That is no longer the case, and other instances of redundancy that we had in this relation have disappeared now. Since there's no redundancy, it is not possible to end up with an inconsistent database. Let's look at some of the other problems. There will not be any insertion anomalies anymore either because the facts that are represented by the forms dependencies are separated in different tables. Therefore, you will also not have deletion anomalies because you can delete one fact without inadvertently deleting other facts for a particular user. There won't be any update anomalies because information is not redundant. Also, you can check it, but there's no information loss here. If you join this table together with this table on email, you will simply get the birth year and current city information appended to this table. So, none of these joined fields, the pair of emails, the pair of birth years, is going to create any additional tuples that were not in the original relation. There's also no dependency loss. There is a separate relation for each one of the functional dependencies we had. Email, interest, determine since age, email determine birth year and current city, and birth year determine salary. Big question is, how do we get there? How do we understand that starting out with this, these are the three relations that we should end up with after our decomposition?

<h1>13 - Functional Dependencies</h1> To understand how to decompose relation in a proper manner, we need to look at the concept of functional dependency. So, here's the definition. If X and Y are sets of attributes in relation, R, then we say that Y is functionally dependent on X if and only if for each X in R, there is precisely one Y in R. Looking at a couple of examples here, current city is functionally dependent on e-mail if for each e-mail value, there is precisely one current city. Here's e-mail value, user one, there is precisely one current city. Why? Because user one is not repeated. Because of that, it is impossible to record a second city. User two determines a single city, user three, a single city. Similarly, with birth year, for each e-mail, there is exactly one birth year. E-mail two, birth year, 69. E-mail user four, birth year, 88, et cetera. Let's take a look at this from dependency e-mail and interest together as a function determine SinceAge. So, when you look at user one and music, user one has been interest in music since the age of 10. User one and music is not repeated anywhere here. So, in this table, it is currently true that the pair of e-mail and interest determines SinceAge. Although it's currently true, how do we make sure that it's always true? We will look at that in just a little bit.

<h1>14 - Full Functional Dependencies</h1> A second definition is that of a full functional dependency. So again, let X and Y be sets of attributes in R. We say Y is fully functional dependent on X if and only if Y is functional dependent on X, and Y is not functional dependent on any proper subset of X. So, let's look at the example again. In this relation here, we would like to represent that Email and Interest together determine SinceAge. That is, SinceAge is not determined by Email alone, and you can see that's true because for the three user ones, the SinceAge has three different values. Similarly, when you look at the interest, for example music, is associated with different SinceAge values. So, SinceAge is in this example fully functional dependent on Interest. Again, as before the question is, how do we make that continue to be true in this relation? Here's an example of a set of forms of dependencies that are not full functional dependencies. So, current city is not fully functional dependent on Email and Interests. Why not? Because it's dependent on Email alone. So, as you see in this example here, every single time you give a particular Email address, there is a single city associated with it. You do not need Email and Interest together to determine a city. So, these are examples of non full functional dependencies.

<h1>15 - Functional Dependencies and Keys</h1> So back to the question then, how do you enforce functional dependencies in a relation? The trick simply is that you use keys. So, if you want to enforce a frontal dependency that X determines Y, then all you need to do is you need to make X the key in that relation. So in this case here, making email and interest a key will guarantee that the functional dependency email and interest to SinceAge. This one here is enforced. Why is that the case? Because by making that pair the key, there will be no duplicate values. Since there are no duplicate values, given a particular email an interest in the table that will determine exactly one SinceAge, namely the one that shows up next to it. This example here, how do we enforce that for a particular email, for a current user? There is a single current city and a single birth year. We do it by making email the key that makes these values unique. That means that if you mention a particular email address like user3, it's going to be in the table a single time, and therefore it's going to have associated with it as single birth year and as a single current city. Third example, if you want to enforce the function dependency birth year determines salary, all you need to do is make birth year the key. That means that if you mentioned a particular birth year like 67, it's going to be in the table as single time, and next to it is going to be the salary that's determined from it. So all of these are functions. There's a function from the pay of email and interest to SinceAge, there's a function from email to birth year function from email to current city, and finally a function from birth year to salary.

<h1>16 - Overview of Normal Forms</h1> To help us recognize how well a relation is laid out, we are going to introduce four normal forms. First, in general, the whole set of data structures is called non-first normal form, NF2. Most of those are not relations in the sense we have defined what a relation is. A subset of the non-first normal form data structures is the set of first normal form relations. A subset of the first normal form relations is the second normal form relations. Within the second normal form relations, there's a subset of third normal form relations. As a subset of the third normal form relations is a set of Boyce-Codd normal form relations. Boyce-Codd normal form relations are the relations we are aiming at. I'm trying to make one additional point with this illustration here. There are certainly first normal form relations that are not in second normal form. There also are second normal form relations that are not in third normal form. However, as illustrated by this small number of relations that are in third normal form but not in Boyce-Codd Normal Form, it is theoretically possible that you have a relation in third normal form that's not also in Boyce-Codd normal form. However, in practice, what happens when you normalize relations from second normal form to third normal form is that you get lucky and actually end up in where we want to be, namely in Boyce-Codd normal form. More about this to come.

<h1>17 - Normal Forms-Definitions</h1> So, let me now define the four normal forms. A relation I set to be in first normal form if all domain values are atomic. But wait, we defined a relation as a data structure where the domain values are pulled from sets of atomic values. So in other words, all relations are automatically born in first normal form. A subset of the first normal form relations are in second normal form. They are in second normal form if and only if every non-key attribute is fully dependent on the key. So, they are a subset of first normal form, and every non-key attribute is fully dependent on the key. A relation is in third normal form, if it is in second normal form, and every non-key attribute is non-transitivity dependent on the key. Finally, and this is the goal, this is the desirable normal form for relations to be in, a relation is in Boyce-Codd normal form or BCNF, if and only if every determinant is a candidate key. To understand that, of course, we need to define the concept of determinant. So, a determinant is a set of attributes in a relation on which some other attribute is fully functional dependent. So, let's take a look at these normal forms, and let's see how we progress through each one of the normal forms when we decompose a relation to end up in Boyce-Codd normal form. Notice that first, second, and third normal form really not our goals in and by themselves. Our goal is to get relations decomposed into Boyce-Codd normal form.

<h1>18 - Kent and Diehr quote</h1> Kent and Diehr gave us an interesting and funny way to remember the first three of these normal forms. All attributes must depend on the key, gives us first normal form. The whole key, that gives a second reform, and nothing but the key, that gives us third normal form, so help me Codd. With references, of course, to the inventor of relation databases, Ted Codd.

<h1>19 - 1NF BCNF flow chart</h1> So, let's take a look at how we can work through normal forms, and of course we'll continue with the example we've been using. Here you have the function dependency diagram, for our example database. You have a relation which says, email and interest in it. Has current city, BirthYear, salary and SinceAge. Function dependence are as follows; email and interest together determines SinceAge, and email alone determines current city, BirthYear, and salary. In addition to that, salary is also determined by BirthYear. So, let's take the first step in decomposing that relation. So, what I want to do is, I want to isolate function dependencies that have different left hand sides. So, as you see here, since email and interest together determines SinceAge, that's a good form of dependency to split out. When you split out that function dependency, you actually also see that at least this portion of the decomposed relation is in boyce-codd normal form. Why is that? Because the only determinant of these three is the pay of email and interest, and they will have to be a candidate key to enforce that functional dependency. What else remains then is, that we need to represent that email determines current city, BirthYear, and salary. That's BirthYear by itself determines salary. What form is this relation in? Well, it is certainly in second normal reform because all of these attributes fully depend on the key, namely email. But unfortunately, there are transitive dependencies. Email determines BirthYear, which in turn determines salary resulting in the forced dependency from email to salary. So, this is not a third normal formulation. So, let us transform this piece of it and let us isolate out email and current city, and BirthYear by itself. So, you have the first relation here as, email form determines current city and BirthYear. What remains then is BirthYear and salary, that you represent by itself. So, what normal form are these relations in? Well, there are no transitive dependencies outside of the key, the email attribute here. Therefore, this is certainly in third normal reform. It is also in Boyce-Codd Normal Form, because the only determinant in this relation is email, and email of course is going to have to be the key to enforce those two forms of dependencies. So, this relation is now in Boyce-Codd Normal Form. This relation is of course also in Boyce-Codd Normal Form. There's no opportunity even for transitive dependencies outside of the key, because there's only one attribute outside of the key. So, this one is in Boyce-Codd Normal Form.

<h1>20 - Compute with Functional Dependencies-Armstrong's rules</h1> To make sure that we do not lose information, and that we preserve the functional dependencies when we decompose relations, we need to be able to compute with meaning. The rules for doing that are called Armstrong's rules. The first is the rule of reflexivity. All it says is that if Y is part of X, then X determines Y as a function. Very simple rule. Easy example, If Y is part of X, in other words if the right hand side is a subset of the left hand side, then the left hand side determines the right hand side. The second rule is the rule of augmentation. So, if X function determines Y, then you can augment it with the same thing on the left hand side or you could augment it with the same thing on the right hand side, or you could augment it on both sides. It will be true, in this case, when you augment on the left hand side, that WX function determines WY. To show you an example of that, let's say Email determines BirthYear, then it will also be true that "Email, Interest" will determine "Birth year, Interest". Finally, very importantly, transitivity. If X function determines Y, and Y function determines Z, then X function determines Z. An example of that here is that if Email determines BirthYear, Email determines BirthYear, and BirthYear determines Salary, as you see here, then Email will determine Salary by transitivity.

<h1>21 - How to guarantee lossless joins</h1> Question now is how do we guarantee lossless joins when we decompose a relation into smaller relations? Here's a very easy way to remember that and to check it. The join field must be a key in at least one of the two relations. So when you look at this decomposition here of relation in two relations, then the join field between these two relations, obviously, is email. If email is a key in one of the two relations as it is here, then we are guaranteed not to lose information from doing this decomposition. In other words, when we join these two relations together again over email, then we are guaranteed to not create additional tuples that were not there in the relation we started out with. The simple way to understand why this is the case is that when the join field is a key as it is here in this one relation when the join field is the key, there's no way of blowing duplicates in this column up with duplicates in this column, and that was exactly what created the lossy join that we saw in example of earlier in this lesson.

<h1>22 - How to guarantee preservation of FDs</h1> Second question is, how do we guarantee preservation of functional dependencies? And here the simple rule is, you're using Armstrong's rules. The meaning implied by the remaining functional dependencies must be the same as the meaning that was implied by the original set. So, looking here at the decomposition of this functional dependency diagram into Email, BirthYear and CurrentCity in one relation, and in a separate relation BirthYear and Salary, as you see there. We can now, by the transitivity rule, see the following, Email determines BirthYear from this relation, and BirthYear determines Salary from this relation, and therefore, by transitivity, Email determines Salary or as you see here, that is implied and therefore, the meaning implied by the remaining functional dependencies is the same. So, in spite of the fact that you do not see Email determining Salary with one relation, by the rule of transitivity, it's implied by this decomposition.

<h1>23 - Email Interest</h1> So, let's go back to the example of a good decomposition that we did before. Again, starting with the function dependency diagram here of our major example. So, first, we decomposed this relation here into these two relations; email and interests together determine SinceAge and email determines current city BirthYear and salary email determining salary. Is this loss less decomposition? Well, remember the rule is that the join field, in this case email, must be a key in at least one of the two relations and of course email here needs to be the key in order to enforce these functional dependencies. So, this is a lossless join. Is it dependency preserving? Yes, it is. This is a very simple case to check if you look at the dependency from email and interest to SinceAge that's directly there. If you look at the three from email to current city BirthYear and salary they are directly here. If you look at the dependency, both year to salary it can be enforced within this one relation. So this one is dependency preserving. So, what happens after we split this one up in these two relations? Let's first check whether it's lossless. So the join attribute here would be BirthYear. BirthYear is clearly the key, in the second relation year therefore, the join is loss less. Is it dependency preserving? Yes, it is because by transitivity email determines BirthYear, which determines salary and therefore implied in the meaning is email determines salary, which is the only one that's actually missing.

<h1>24 - 3NF and BCNF</h1> So, as I hinted at when I showed you the Venn diagram of the sets of different normal formulations, third normal formulations are a proper subset of the set of Boyce-Codd normal formulations. That means that there does exist relations, which using lossless and dependency preserving decompositions, can only be normalized to third normal form, not also to Boyce-Codd normal form. This only happens in cases where relation has overlapping keys.

<h1>25 - It Nevers Happens in Practice</h1> As illustrated by the Venn diagram, this really never happens in practice. I'm going to show you a proof by experience. Proof has two steps to it. Number one: it never happened to me in 35 years. I've designed a lot of databases in industry, in government, and in the university, and it never happened to me. As a second part of the proof, take a look at one of the bookcases in my office. So, this one bookcase contains data-based textbooks only. Every single one of these textbooks has in it a chapter on database normalization. They will show you first normal form, second normal form, third normal form, and Boyce-Codd normal form. Then coming to the bottom of the right page, it says, "However, there does exist relations that can only be decomposed to third normal form and not Boyce-Codd normal form." With shaking fingers you turned the page to see such an example and they change the example on you. Why is that the case? Because it takes a really sick brain to construct an example like that. So, be confident if you follow the steps and bring relations through first, second, third normal form you will be lucky and you will end up in Boyce-Codd normal form in practice.

