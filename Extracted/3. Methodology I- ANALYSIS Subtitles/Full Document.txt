<h1>3. Methodology I- ANALYSIS </h1></br><h1>1 - Database Application Development Methodology-Assumptions - </h1> The database application development methodology was specifically designed for applications that are supported by databases, it will not work in general for software development projects. Furthermore, in order for the methodology to work certain assumptions must hold true. The assumptions are as follows. We assume that business processes are well designed. We assume that all documents are known. We assume that tasks are known. We assume that the system boundary is known, and we assume that one database schema unifying all views can be designed for the database. Documents represent anything that's input to or output from the applications that run on the database. The tasks represent the processing that takes place using those input documents, and generating those output documents, and appropriately updating the database in the process. If we cannot create a database scheme that unifies all the views, then the methodology fails. Anyone who has been associated with a database development project knows that this is an incredibly difficult task. In an organization there are many many different interests that need to be unified. People may have different goals. There may be power struggles involved. There might be company politics involved, etc. Without a doubt, this is the most difficult part of the whole process. You might ask the questions, if it's that difficult, is that a problem with the methodology or is it a problem with the organization? It is always a problem with the organization. One definition of an organization is that it's an entity created to pursue a shared set of goals. So if the organization cannot successfully arrive at such a unifying view, then it's a problem with the organization.

<h1>2 - The Software Process - </h1> As you know from your software engineering class, a waterfall software process, typically consists of the following phases. There's a business process design phase, analysis, specification, design, implementation, and then followed by testing, operation, and maintenance. And then, of course, there's the management of the whole process. All of these phases are needed in a database application development methodology also. However, in this course, we are only going to look at those that are actually unique for database development, and they are analysis, specification, design, and implementation.

<h1>3 - Overview of Methodology Data First - </h1> Let me now give you an overview of the methodology. In database application development methodologies data is always first. In general software development methodologies process is often first. So, they will concentrate on laying out the class diagrams in just the right way to get the functionality just the right way. And then they will hang the data onto the classes where they fit. In database development it's data first. And once data is designed just right, we would hang the processes on where they fit. So, the four phases are Analysis, Specification, Design, and Implementation. So the idea is that in the analysis phase here, we start with all the information that's provided by the customer, and then the end product, the output of the analysis phase, is an information flow diagram. That diagram again together with all the information provided by the customer constitutes the input to the specification process. Remember data is first. So in the specification process, the first thing we do is to create an Diagram or EER diagram representing the data. With that as a foundation, we then go ahead and create a specification of the tasks, or applications that need to run on the database represented by this Or EER diagram. Then in design, we first concentrate on translating the diagram to a relational database schema. With that in place, we now take the task that represented what needs to happen on the Diagram and represent in an abstract code, accessing the relational database represented by the schema. Finally in the implementation step, we take the relational database schema,and we use a specific implementation in our sample case, use MySQL, to create the relational database. We then look at the abstract code with the embedded SQL and use a programming language, like for example PHP, with embedded SQL to represent the tests that need to run on this database. That brings us all the way from analysis, starting with customer requirements, all the way to a running database application implementation. Needless to say if we don't know the customer's requirements, the methodology is not going to result in a database application that meets any requirements that user might have.

<h1>4 - Example Project Description - </h1> In order to proceed with a description of the database application development methodology, we need an example project description. As I stated, we assume that the business process, the documents, tasks, and system boundary are all well known before we can start deploying the database development methodology. It certainly would be preferable to have a group of real users to discuss the requirements with. Short of that I'm going to go through a project description that represents the customer. If you don't read that description you won't be able to get anything out of the rest of this course.

<h1>5 - (headshot) GTOnline Networking Application - </h1> I believe in learning by example, and learning by doing. That's why there are two parallel activities in the course. One is an example, the other one is the project. As the example, we are going to use GTOnline. That's a lite social networking site, for networking socialites. It is a simple networking application that provides features similar to those in Facebook and LinkedIn.

<h1>6 - Analysis - </h1> Coming back from the first detour where you've familiarized yourself with the document that represents the customers requirements to this future database application system. We are now ready to do analysis. In the analysis, we are going to take the customers requirements and from those we are going to create a information flow diagram.

<h1>7 - Analysis-Information Flow Diagram - </h1> Here's the notation we're going to use for an information flow diagram. The ellipsis represent tasks. The documents represent input and output screens, as you've seen in the requirements specification. The arrows represent information flow. Very importantly, information flow. Not control flow. So this is not a flowchart, this is a chart that shows potential information flow through the arrows. And then finally, the broken line here represents the system boundary. So in this example here, we are implementing a system and you can see the boundary of the system here is what we're implementing. Inside on that system there is a number of tasks, task T1, T2, T3 and T4. There's also a number of documents that we use to interact with the system, D1, D2, D3, D4, etc. If you look at document D1, then document D1 is an input document to test T1. Test T1 may then interact with the database by writing things in the database and reading things from the database. Document D2 is both an input and an output document. Test T1 will read information from D2, will interact with the database potentially writing in the database and reading from the database and returning information to document D2. It's possible that a task can interact with multiple documents, as you see here. So, as I mentioned before, this is an information flow diagram, not a control flow diagram. There are some rules of this symbolic language. You never connect two documents. You never connect two tasks. So these are the only ways that the document is allowed to be constructed.

<h1>8 - Requirements 01 - </h1> Having now read the document that describes the client's requirements, let us now analyze some of those requirements in more detail. So all users will log in via the GTOnline login screen. Users are uniquely identified by their email address and providing a correct email password combination and hitting log in, the user will be logged into the system. If a wrong incorrect combination of email and password is presented on the screen, then the user should be sent to some error message, and back to the login screen to try again. If a user has not previously logged in, then he or she needs to register first, by pushing the Register button. Notice, as the user interacts with the login screen, the information provided is not written into the database as a result of the login process. However, the test that checks the login information will read information from the database to make sure that the user who's about to login in is a valid user, and has provided the correct email and password. So this is purely an input document.

<h1>9 - Requirements 02 - </h1> On the register screen the new user first provides first name and last name, and then an email and password, together with a confirmation of that password. If that email is not previously used by another user, and if the password and the confirmed password are identical, then the result of this will be that a new user is created with that email and password. Should the user join this process, remember that he has been previously registered. They can push cancel, which would send them back to the login screen. Notice that the register document is an input document to the system, and as a result of interacting with that registration task, the information will be written into the database.

<h1>10 - Requirements 03 - </h1> Immediately after registering, a new user would be sent to the edit profile screen. The edit profile screen contains some personal information, list of interests, their education, and their professional information. The basic personal information contains sex, birthday, current city, hometown, and a list of interests. Entering the personal information and hitting save will save that information. Any number of interests can be added, one at a time, by using the add button and typing the interest in that field. To add a school, the new user uses the drop-down menu and types in the year graduated, if applicable, and hit save. Similarly, to add a new job, the user enters the information by picking from the drop-down, enters the job title, and says save. The edit profile screen, obviously, is going to be solved in potentially many types of information being written into the database, the person's information, interests, education information and profession information. But, notice that there will also be information that's read from the database. For example, because the drop down-list for school and the drop-down list for employer needs to be consoled in the database to populate the screen.

<h1>11 - Requirements 04 - </h1> Let's now see what that looks like from the view profile screen. You see that Michael Bluth now has Sex, BirthDate, Currency, Hometown, and a list of Interests entered. He also has two schools entered one is a college/university, the other one is a high school. He has graduated from both. He also has a job in the tier with a title Assistant to the Regional Manager. As you noticed on the previous screen, to enter a school there was a drop-down menu. Likewise, to enter an employer for a job there was a drop-down menu. A number of administrative users behind the scenes will maintain the list of scores and the list of employers. The View Profile screen also contains a number of links that will allow you to go to other screens. For example, the view friend screen will show the list of Friends for this particular user. Log Out, of course, will log you out of the system. The View Pending Requests screen, you could see the list of friends' requests that have not yet been accepted or rejected. And the Edit Profile link will send you back to the Edit Profile screen that we looked at previously. Notice that the View Profile screen is not an input to the database, it is an output document from the database where all the information about the user's profile has been read from the database and written onto this output document. There is, of course, control information here that leads you to a different screen, depending on which link you choose.

<h1>12 - Requirements 05 - </h1> The search screen is an output document. It returns to search result based on the search criteria. The request new friends screen is an input document to the system. The pending friend request screen for Michael Bluth shows here the people that have requested to be friends with Michael. Michael can then either then push accept or reject for each one of these friends. This is the list of friends with whom you have requested to become friends. So Phyllis here, you have asked to be friends with Phyllis. You could decide to cancel that request if you want to. This document is both an input and output document. It's an output document from the database because it displays information from the database. It is also an input document to the database because it will cause changes in the database depending on whether you hit the Accept or Reject button. Of course if you hit the Cancel button it will delete your request to Phyllis for her to become a friend of yours. The friends' list form is an output document from the database.

<h1>13 - IFD chart - </h1> The output of the analysis phase of the database application developement methodology is an information flow diagram. Here is the information flow diagram that results from our analysis of the requirements to the system. Let's first look at the form Log In. So the Log In Form is an input to the Log In task. The Log In task reads from the Database to confirm that the combination of email address and password is correct, and if it is logs in the user. The Registration Form is an input document, the result of providing the registration information right in to the Database, that information for that new user. The Profile Edit document is both an input document and an output document. It's an input document in that both personal information, interests, education information, and professional information is going to be written in to the Database, potentially. It's also an output document, because to populate with school and employee information in the Profile document, a read from the Database is necessary. The View Profile document is simply an output document from reading the corresponding information from the Database. Likewise the Friends List is a read from the Database, so the Friends List is an output document only. We have not talked about the Status/Comments document. It is used for many different things, for example, viewing the status and updates it serves as an output document. If you want to add a status update it's an input document. If you want to add comments about someone's status update then it's an input document. Read more about that in the requirement description. The Friends Search and Results document is an input and an output document. When the search criteria are given to the search for friends database qualified potential future friends will be read from the Database and written on to the document. The Friend Request document is an input document. The information on it will result in writes to the Database about the request that has been made. The Pending Friends List Is both an input and an output document. It will be populated by a read from the Database and you taking action starts as accepting or rejecting an invitation will result in a write in to the database. There are several things that I want to know this year. First, I followed the syntax and the rules for creating information flow diagrams presented earlier. Notice, how the names of the input-output documents in the test very, very closely reflect those that I used in the requirements document. The information flow diagram is just a first, high-level specification of the system. As we analyze further the tasks of the system, you will learn much more about what they need to do. In spite of that, it is not necessary to go back and refine this information flow diagram. There's only so much you can code by boxes and baubles. So, just take this as the first, top-level specification of the system, which will form the basis for the next phase of the methodology. So the information flow diagram clearly models the system that was described by the customer.

<h1>14 - Don't Go There - </h1> Instead of the information flow diagram modeling clearly, the requirements of the customer. As a software engineer or computer scientist you might be tempted instead to think about it as follows. It's an application, you got to log on to it. So, there's a log in document and a log in task. You got to maintain the data base. There's a bunch of documents involved in that maintenance, as input and output. And you need to generate some reports as output. So, the application will have three tasks, login, maintain the database, and generate the report. Don't do that. That does not model the future system you're building. There's models programs, code, etc. That's not what you want to do.

<h1>15 - Specification v2 - </h1> We have now looked at the customer's requirements to this application system. From those requirements we designed an information flow diagram. The next phase in our database application methodology is that of specification. We are going to concentrate on specifying the database. In order to do that, we're going to look at the input/output documents to the system and we're going to use those to help us design an extended entity relationship diagram representing a specification of the database. Subsequent to that, we are then going to look at the tasks of the information flow diagram and from each one of those we are going to provide a specification of what the task will do relative to the input and output documents and the database that we have now designed. With a little bit more detail, the output of the specification phase will be an extended entity relationship diagram, data formats, constraints, and then the task decomposition.

<h1>16 - What goes in out of the Database - </h1> Given an information flow diagram, with documents that are input documents to the database or output documents from the database, how does one go about creating a specification of the database? When the database discipline was young, people talked about this as the art of database specification, or the are of database design. Over the years I have developed this database development methodology, and it attempts to take some of the art out of the process and add in some mechanical steps. So I have two fundamental questions. One is, what goes into the database? And the second one is, what comes out of the database? Corresponding to each one of these two, I have two observations. First, observations related to what goes into the database. So everything in the database has got to come from somewhere. It doesn't happen by magic. And everything on an input document, must go somewhere corresponding with the second question, I have these two observations. Everything in the database should be used for something, otherwise why is it in the database? And everything on an output document must come from somewhere. We are now going to proceed by looking at the documents, and using these four observations to help us create a specification of the database.

<h1>17 - DETOUR_ EER MODEL - </h1> Before we go any further, we need a small detour to study an additional database tool or technique

