<h1>10. Relational Algebra and Calculus </h1></br><h1>1 - Closed Algebra</h1> Closed algebra is the reason we don't run around in loincloth anymore. Let me show you an example. Here's an expression on rational numbers. What's the result? Come on, you ought to be able to do that. First, you are Georgia Tech student. Well, at least you know what to do. You take the five and the three, gives you eight, multiplied by the seven. And the result is 56. You subtract 21, you get 35, then you multiply by three, gives you 105. Then you add the 10 and five for 15, you divide 105 by 15. Then finally you multiply the seven by the three, to give you the final result 21. So, the algebra is said to be closed because each time you do an operation on these rational numbers you get a rational number back. The same type as the operands you started out with. That's what a closed algebra is. A closed algebra allows you to formulate higher level models. So, there's no less than one, two, three, four, five, six, seven different thoughts involved in this. Each one built on the next one. So, a closed algebra allows you to use previous thoughts to form new thoughts to build high level models. And that is indeed why we don't run around in loincloth anymore.

<h1>2 - Relational Algebra Operators</h1> Let's take a look at the four groups of algebra operators. First, we have four operators that are all set operators. As you can see here, we got set union between two sets, R n S, set intersection, set difference, and Cartesian product. As you can already guess now from looking just at these, it is not all the operators that are fundamental operators, some of them are derived or composed from others. Second, we have two special operators. One is a projection operator that you can think of as eliminating columns from a result, the second one is a selection operator which you can think of as eliminating rows. The third group is a group of operators that in general are called joins. These are constructor operations. We have an operator called natural join, we have outer joins, there are three of those, a left and right and a full and then we have theta-joins. Find the two additional operators that are quite special, one is the divideby operator. Essentially, the divideby operator allows you to do something similar to universal quantification in relational calculus. The rename operator, Greek letter r or row. is essentially an operator that allows you to manipulate the names of attributes of relations in such a way that you can get your join operators, and your set operators to work in the way you intend them to work.

<h1>3 - Selection</h1> Let's first look at the selection operator. The general syntax is select all the tuples from relation R that satisfy this expression. Let's look at an example. Let's find all RegularUsers. So, there's no subexpression that has to be true here. So, let's take a look at what the result is. If this is our RegularUser table with Email, Birth Year, Sex, Current City, HomeTown, and we got one, two, three, four, five to present it right now, then the result of that is going to be every single one of the tuples. Why? Because there was no selection expression. So, all of them qualify as part of the result. So, the result of the query is this.

<h1>4 - Selection-Simple Expression</h1> Second, let's take a look at an example of the selection operator with a simple expression. So, let's say we want to find all RegularUsers with HomeTown Atlanta. The relational algebraic expression is this, select where the expression condition is HomeTown equals the value Atlanta from RegularUser. In general, when we form simple expressions, we can do it in one of the following two ways. We can take an attribute name, and compare to a constant. The comparison operators are the usual suspects: equal to, less than, less than equal to, et cetera. Or alternatively, we can say attribute one compares to attribute two in the following way, either equal to less than, less than equal to et cetera. So, let's take a look at the result. The first rule here satisfies the requirement that HomeTown equals Atlanta. So, that appears in the result. Second one doesn't. Third one does. So, that appears in the result. Fourth tuple does. So, that appears in the result. The fifth tuple does not. So therefore, the three tuples that satisfy HomeTown equals Atlanta is what comes back in the result. Notice that all the columns of the RegularUser table are also present in the result of the selection query.

<h1>5 - Selection-Composite Expression</h1> Now let's look at a selection with a composite expression. Let's say we want to find all regular users with the same current city and HomeTown, or with HomeTown equals Atlanta. The query is formulated as follows. Select from regular user where current city equals HomeTown or HomeTown equal say 'Atlanta'. So, it's a disjunction. In general, we can form composite expressions from simple, or other expressions as follows. Take two expressions, expression one and two, you can add them together or use conjunction. Also, mathematically normally expressed as follows, or you can take a expression one and expression two and do disjunction or or, mathematically disjunction is normally represented by the following notation. You can take an expression and put parentheses around it. The power of that is that you can change the order of the evaluation. Finally, you can take the expression into the negation of it. And now to our example. So, we're going to look in RegularUser for tuples with current city equals HomeTown, or HomeTown equals 'Atlanta'. So, in this tuple, HomeTown equals 'Atlanta' and therefore that tuple qualifies as member of the result. In the second tuple, current city and HomeTown are the same 

<h1>6 - Projection</h1> The next operator is projection. The Syntax is as follows, use the Greek letter pi, and it says, project from relation R. The following attributes A1, A2, up through An, where A1, A2 up through An is a subset of the set of attributes in relation R. So, let's say, we want to find email, birth year and sex for all regular users in Atlanta. So, one way to express their career is the following. We take a look at the regular user table, we find all of those tuples that have a hometown equal to Atlanta thus satisfying this requirement. Then after that, we project on the attributes we want; email, birth year and sex as expressed up here. So, which of these regular users live in Atlanta? Well, user number one lives in Atlanta, and what are the email birth year and sex for user1? It's here; email, birth year and sex. User4 happens to live in Atlanta too. So, for user4, we also put in the result email, and birth year and sex. User number six lives in Atlanta. So, we get user6 email, birth year and sex. User10 and user12 do not live in Atlanta. So, they do not add anything to the result of the query. One thing which is very interesting to notice here is not just what projection is. So, clearly as you can see here with email, and birth year and sex, that is a projection from the state because it leaves out current city and hometown. That's what projections do. What is very, very interesting here with this query refers back to what I talked about earlier, that relational algebra is a closed query language. Because what actually happens here is that this query here is done in two steps, when we formulated. First, we take regular user and do a selection from it with a selection condition. Then from the result of that, which we know is a relation, we then do the projection on that. So, does a composite, query, using two operators and this can only be done when your algebra is closed.

<h1>7 - Relations are Sets</h1> I want to stress the fact that relation are sets. So let's say we want to write a query, find the sex for RegularUsers in Atlanta. The way we could write that is as follows, select where HomeTown equals Atlanta from RegularUser and then project that on sex. Let's take a look at the result. So we have here three tables of users from Atlanta. When you look at the sex there's one female, one male, and one female. So what is the result of that query? Well, the result is this one. Notice that male appears once and female appears once in spite of the fact that two of the tables in RegularUser have sex female. So in other words, relations are sets. Again, relation rlgebra is a close clear language. You start with a relation, you end with a relation, relation is a set. Therefore, you only have the two rows male and female.

<h1>8 - Union-U</h1> Let's take a look at the Set-based Operator Union. So, here's an example. Find all cities that are a current city or a hometown for some regular user. Because of the "or", we clearly have a union involved here. So, drawing a Venn diagram, it will look as follows. So, think about this as the current city and this as hometown, and because it says "or", we are looking for all the tools that satisfy either one or both of those conditions. Now, let's see how that's written in Algebra. It's going to take regular user, project on current city, going to take regular user, project on hometown and then, we're going to do with the union of them. One side common, that's important. In union, in set intersection, in set difference, the two operands of the operator must be type compatible. Type compatibility is a very simple definition in relation to databases. Basically, what it says is that the number of attributes of the two operands must be the same. Here, we see there's one attribute here, there's one attribute here, and the second condition is that the types must be compatible, and if you look back a bit, you'll see in our examples, we have defined current city and hometown as 50. So, they are compatible. So, back to look at the Union example. So, the query could be evaluated as follows: current city is computed from regular user that San Francisco, Las Vegas, Dallas, and College Park in the result. Similarly, if we project on hometown from regular user, we get Atlanta, Dallas, and Austin. Remember, Atlanta is not repeated because the result is a set. So, those two results now union together gives you this result set here. So, San Francisco is in there. Las Vegas is, Dallas is, and College Park is and then Atlanta but only once. Dallas is not repeated again because we already have that, and finally comes Austin.

<h1>9 - Intersection</h1> Second set based operator intersection. Here's an example in English. Find all cities that are a current city for someone and a hometown for someone. So, showing that at a Venn diagram, you're looking at the following, say these are the current cities, these are the hometowns, and since it says both conditions must be satisfied, we're looking for the tuples that satisfy the condition in this intersection. The query is formulated as follows. Take regular user project on current city, take regular user project on hometown and do the intersection. So, take a look at the result. So, the projection on current city gives you San Francisco, San Diego, Las Vegas and Dallas. The projection on hometown gives you Atlanta, San Francisco, Atlanta and Dallas. Except of course, Atlanta is not repeated. Doing the intersection of those will yield the following result. San Francisco is part of the result because it appears both places, San Diego is not because it doesn't appear in this, Las Vegas is not because it doesn't appear here, Dallas appears over here, so that's part of the result. So, the result is this set.

<h1>10 - Set Difference</h1> Finally, let's look at Set Difference. So, in the query, we want to find cities that are a CurrentCity for some RegularUser, but not also a HomeTown for some RegularUser. So, looking at the Venn diagram, we see the following: got a set here corresponding to CurrentCity, got a set here corresponding to HomeTown, and in the result we are looking for all of those that have this CurrentCity but excluding all of these, which in essence just means we're excluding these in here. So these out here do not even get to play in the query. Here's how it's formulated. Take RegularUser, project it on CurrentCity, take RegularUser, project it on HomeTown, take the latter away from the former. So, in the example here, Seattle is part of the result because it doesn't appear over here. College Park is part of the result because it does not appear over here, same thing with Las Vegas. Dallas is not part of the result because it appears over here. College Park is not added because it's already over there, and the result is a set. So, the result of the query is this.

<h1>11 - Natural Join</h1> Now, let's look at natural join, the first one of our constructor operators. So, I'm going to be combining two relations to answer the following query. Find E-mail, Year, Sex, and Event when the (Birth)Year of the RegularUser is the same one as the (Event)Year of the Major60sEvents. So, the algebra query looks like this, take RegularUser, natural join Major60sEvents. Take a look at the two relations, here's the RegularUser relation, it has E-mail, Year, and Sex. Here's the Major60sEvents, it has Year and Event. What natural join does in combining these two tables is it looks at which attribute names are the same. In this case, Year appears in both tables and no other attributes have the same name. Therefore, the natural join operation is going to compare tuples from the RegularUser relation with tuples from the Major60sEvents relation and see if the year is the same. So, let's see what the result is going to be. So, user1 is born in 1985, none of these Major60sEvents happened in 1985. So, user1 is not going to contribute to the result. Let's take a look at user2, user2 was born in 69. What happened in 69? Well, we had the Moon Landing happened in 69. So, user2, born in 69, sex, Male, that comes from this tuple is combined with the Moon Landing tuple which appears here. Notice that Year is only recorded one time. User3 is born in 67. User3, born in 67, matches the Year that the Alabama song was recorded by The Doors. So, those two tuples get combined. User8, born in 68, matches a number of events: Bloody Sunday, the MLK assassination, and the Tet offensive. So, all of those get combined. So, here were some of the properties of a natural join. First of all, it matches values of attributes with the same names and only those. It keeps only one copy of the join attribute. It's called an inner join because only the tuples that actually appear in the relation and match will appear in the result. Those that have no matches will not appear in the result.

<h1>12 - Theta Join</h1> The second constructor operator we'll look at is theta join. Let's say we want to find email, birth year, sex, event year, when the birth year of the regular user comes before the event year of the major event. When we use the theta join for that the join condition is that birth year precedes event year. In contrast to the natural join, this would have been an equality, but there is one more difference that we will see in just a second. So here we have the regular user table again, here we have the major events table, and let's take a look at when the birth year precedes the event year. So, 85 for user one does not precede any of the 60s event years. So if you look at user2, was born in 69, and 69 does not precede any of the 60s events we have recorded over here, so user2 does not contribute to the result. User3 however, was born in 67. 67 precedes a number of the events in the event table. So, let's take a look at it. So 67 precedes the year of the Tet offensive which was 68, the bloody Sunday which was 68, the MLK assassination which was 68, and the moon landing which was 69. So, user3 gets combined with all of those events. About user8. User8 was born in 68. 68 comes a year before 69 and therefore user8 gets combined with the moon landing in the lace tubule in the result. In contrast to the natural join, in this case, the two join attributes have different names whereas in the natural join, they had the same name. Also in contrast to the natural join, both of the join attributes will appear in the result. Birth year appears, and event year appears. The comparison that's allowed here in the theta join is any of the usual suspects. Less than, greater than, equal to, different from etc. As I mentioned, all attributes are preserved. This is also an inner join because the things in the two tables that do not match each other do not contribute to a tubule in the result table.

<h1>13 - Left Outer Join</h1> The third construct to operate off the relation as a bar is outer join. In this case it's (left) outer Join signified by those two small lines on the join symbol. Let's say we want to find e-mail, year, sex and event for RegularUsers when the birth year of the RegularUser matches the event year of the event. But let's in addition to that say that we want to preserve RegularUser information even if their birth year does not match any event. The Algebra expression will look like this, Outer Join RegularUser with Major60sEvents. So, let's take a look at user three first. User three is born in '67. '67 matches the year that The Doors recorded the Alabama Song. So, user three here gets combined with the Alabama Song, and the result appears here. User eight who was born in '68 will be combined with the three events that happened in '68, The Tet Offensive, Bloody Sunday, and the MLK assassination. So, that is the next, three tables in the result. Together, those first four are called the "inner" part of the query. Now, let's then go take a look at user one and use 10. As you see, their birth years do not match anything on the major '60's events table. Therefore there's nothing to match them up with but as we said up in the query here, we would still like to preserve the RegularUser information. So, you see here the user one information and the user 10 information and in both cases they have a null associated with them. So that null, this is called The Outer part or signifies the outer part of that result. So, in this case the (left) outer join I showed you really was a natural (left) outer join because we compared same values. It is a special case of the theta-join.

<h1>14 - Cartesian Product-X</h1> The fourth constructor operator in the relational algebra is Cartesian product. A Cartesian product simply combines every single tuple into two operands. So, every single regular user tuple will be combined with every single user interest tuple. For example, here, you have user four. User four is going to be combined with every single one of these. For example, this one, as you see, that combination appears here. You might wonder what the usefulness of such a combination would be. After all, there were no comparison rules that would decide when two tuples in the operands would be combined in the result, everything is combined. So, what could that be useful for?

<h1>15 - Cartesian Product-Can be Useful</h1> Although Cartesian Product combines troopers, that have nothing to do with each other, there's a very interesting portable use of it. So, let's look at our example here. You got the regular user table with user one, two, three and 12. You've got the UserInterests table here that record the interest in this case for user one and for user two who has two and for use three. So, those are all the currently known UserInterests. Let's say we want to do an email blast to all regular users to make them aware of all the interests they currently are not hooked up with. In that case, we sort of need that complement to this table. How could we do that? The first thing we do is we take the regular user table and we project that on email. That is what we are doing here. Take the regular user projected on email. So, the intermediate result of that query is the email column of regular user. Second, we take the UserInterests table and project that on interest, that gives us all a set of interests that are currently recorded for any user in the database. So UserInterests projected on interest, that's another single column table. Now, we have that single column intermediate result and that single column intermediate result. Now, we simply do the Cartesian Product of the two. Which is combined user one with all interest user two, with all interest user three, with all interest and user 12, with all interests. All we now need to do, in order to end up with a result that has every single user hooked up with all the interest they currently do not have is now to actually just subtract the current UserInterest from the intermediate result. So, that's what we do here. We subtract the UserInterests table, email and interest. Notice that the two operands in the subtraction are type compatible in this case here because you have email Cartesian Product interest and you subtract from that email and interest. So, when you look at for example, user one, user one was hooked up with the interest music, but was not hooked up with blogging and meditation. Therefore, when the result, you now see user one hooked up with both blogging and meditation. That did not previously appear in the current interests.

<h1>17 - Rename</h1> Next algebra operator we'll look at is the Rename Operator Rome, Greek letter for R. Rename is useful when we want to control whether a natural join, a theta join or some other type of join takes place. As you noticed when I presented the previous three for operators, I was renaming the attributes to make the operator work like it was supposed to do. Here is how to actually make that happen. The formal syntax for renaming is as follows. Row followed by the following expression. What's in that expression is the name of the relation as it currently is and the name of the result relation after renaming. In the subscript here is the list of attributes that get renamed. So we are renaming sex to gender and birth year to year. Let's take a look at it. So we start out with the regular user relation and we rename it to Ruser as you see there. Then, sex is renamed to gender. You see that here and birth year is renamed to year. You see that here.

<h1>18 - (headshot) Relational Calculus intro</h1> So we have now looked at relational algebra. That's one of the two fundamental formalism's for relational database query languages. The second one is relational calculus. To distinguish between the two, relational algebra is procedural in nature. It's operator-based and basically what you do is you say, "Take this relation, take that relation, join them together. Take the result of that, do a projection. Take the result of that, do a selection." You're basically describing step-by-step what you're supposed to do to get to the result. Calculus, in comparison, is declarative in nature. Instead of saying what to do step-by-step you simply describe the result that you want. So it may appear that it's a higher level language with more expressive power. As it turns out, the algebra and calculus were defined in such a manner that with respect to data retrieval of horsepower, they can actually be shown to be equivalent. SQL is mostly based on tuple calculus. So, now on to calculus.

<h1>19 - Relational Caculus Expressions</h1> The second formalism in which we can express queries on relational databases is called Relational Calculus. In this particular case we're going to look at relational Tuple calculus. It's called Tuple calculus because queries have variables that range or with sets of Tuples. As you can already see now, queries in relation to Tuple Calculus are declarative in nature as opposed to the relational algebra which is operator based and is procedural in nature. So the semantics of a query like this is to find a set of Tuples T that satisfy the predicate P. Predicates are built from atoms. So let's take a look at some of the atoms that go into predicates. So first they are range expressions. A range expressions says for example in this case here that T is a member of relational or written in an alternative format contains Tuple T. We need to be able to reference attributes of Tuples. We used to dot notation for that. So this notation indicates that we are looking at the value of attribute a of Tuple T. Third, constants in our queries are denoted by C. Fourth, we have several comparison operators theta, equal to, different from, less than equal to, greater than equal to, less than and greater than. Atoms are then any one of the following. Could be a range expression, it could be a comparison of two attributes, here Tuple R, attribute A compared by the theta here to attribute B of Tuple S and again the theta could be any one of these comparison operators. Alternatively we could compare attribute A of tuple R to the constant C, and again all of these could be the comparison operator. Building up then what a predicate is, an atom is a predicate. So this means that the range expression, the attribute comparison expression and comparing an attribute to a constant. Those are all predicates. Now, if you have predicates P one and P two then you can put parentheses around them which basically means you can use nesting in the way you write your expressions. You can use negation, you can use or, you can use and, and you can use implies. Finally, if P of T is a predicate and T is a free variable in P and I is a relation, then there exists a T in R that satisfies P as a predicate. Likewise for all T and R for which P is true is also a predicate. If T is free in the predicate P, then using the extended quantifier or the universal quantifier binds T.

<h1>20 - Selection-CALC</h1> Now, let's take a look at the first very, very simple operation expressed in tuple calculus, namely that of a selection. As you will see in the following, I'm using your understanding of relational algebra operators and essentially going through some of those in order to show you how they are expressed in tuple calculus. In that first example, let's try to find all regular users. The way that's written in tuple calculus is find the set r, where r is a member of the relation regular user. In this example here, what is it we are attempting to do? We are simply attempting to find every single tuple in the relation regular user. So therefore, the first tuple here is part of the result, second tuple is part of the result, et cetera. The result from this operation is identical to the relation we started with.

<h1>21 - Selection-Composite Expression-CALC</h1> Let's make it a little bit more complicated. Let's take a look at a selection that has a composite expression. So, here's what we want to do. Want to find all regular users who have the same CurrentCity and HomeTown or who have the HomeTown, Atlanta. Query is expressed as follows: find a set of tuples r, where r is a member of RegularUser and the following is true: either CurrentCity most equal HomeTown or the HomeTown must be Atlanta. This reflects directly what is asked for here namely that the tuple must satisfy CurrentCity is equal to HomeTown or HomeTown equals Atlanta. Looking at the example here, see which tuples become part of the result of the query here. So, here, is it the case that CurrentCity and hometown is the same? No, it's not. Well, is it then the case that the HomeTown equals Atlanta? Yes, it is. In other words, this one evaluate to true since this is a disjunction, this whole thing evaluates to true, and r is a tuple in RegularUser. So, therefore, the first tuple we looked at satisfies the query, and so there you go. What about the second one? Is HomeTown equal to CurrentCity? Yes, it is. So, user2 is part of the result of the query. Is San Diego equal to Portland? No, it's not. Is hometown equal to Atlanta? No, it's not. So, as you see, user3 is not part of the result. User4, Hometown is Atlanta, user4 in the result. Finally, user10, HomeTown equals CurrentCity, is part of the result.

<h1>22 - Projection-CALC</h1> Next, let's look at projection in tuple calculus. Let's say we want to find Email, BirthYear, and Sex for RegularUser's with HomeTown Atlanta. So, we write it as follows. We want Email, BirthYear, and Sex directly reflecting what is asked for in the projection, that is of tuples that are in RegularUser, where the corresponding HomeTown equals Atlanta. Are we going to include in this result user1, 1985, male? Yes, we are. It's a tuple in RegularUser and HomeTown equals Atlanta. So, user1, 85, and male is part of the result. What about user4? Yes, HomeTown is Atlanta. What about user6? Yes. What about user10? No. User12? No. So, the result consists of parts of the first three tuples namely, the three attributes we are projecting on Email, BirthYear, and Sex from those first three tuples, user1, user4, and user6.

<h1>23 - Union-CALC</h1> Let us now look at Union. Let us find all cities that are either a CurrentCity or HomeTown for some RegularUser. So, the cities we're interested in are the following cities. If there exists a tuple r in RegularUser with a CurrentCity, then that's part of the result. Alternatively, if there exists a tuple in RegularUser with a HomeTown, then that's one of the cities. Let's first look at the current cities. So, San Francisco is a current city, so it's clearly part of the result. Las Vegas is part of the result. Dallas is part of the result. College Park, part of the result. What about Atlanta? Yes, part of the result. What about Atlanta? Well, Atlanta is already there and the result is a set, of course. What about Austin? Yeah. Austin is there and part of the result.

<h1>24 - Intersection-CALC</h1> Now to intersection, so we're going to use the same example but this time instead we're going to find the cities that are a CurrentCity for some user and a HomeTown for some user. Not necessarily the same user of course. So for a City S to qualify, there must exist a table in RegularUser that has the CurrentCity as that City. It must also be the case that there's a table t in RegularUser that has that City as the HomeTown. So what about San Francisco? Is that going to qualify? Well, San Francisco is certainly a CurrentCity for user four. Is San Francisco also a HomeTown for some user? Yes, it is. It is for user six. So San Francisco is part of the result. What about San Diego? That's a CurrentCity. Well, it's not part of the result because it's not a HomeTown for anyone. How about Las Vegas then? Same thing. It's not a HomeTown for anyone. How about Dallas? Yes, Dallas is part of the result because Dallas is also a HomeTown for someone. In this case actually the same one. So the result is San Francisco and Dallas.

<h1>25 - Set Difference-CALC</h1> Now, let's look at set difference. We're using the same example with slight modifications. Find all cities that are current city for some regular user but exclude those that are a hometown for some regular users. Of course, not necessarily the same regular user. So, we are looking for cities that are found the following way. There must exist a tubule r in regular user that has that city as a current city. But it must also be true that there does not exist a tubule t in regular user where that city appears as hometown. So, let's see here. What about Seattle? Well, Seattle is part of the result because it appears here as a current city and no one has Seattle as hometown. College Park, same thing, is not a hometown for anyone. Las Vegas is not a hometown for anyone, so it's in the result. Dallas however is a hometown for someone so it's not in the result. College Park, we already have that and the result is as said. So the result of the quiz, Seattle, College Park and Las Vegas.

<h1>26 - Natural Join-CALC</h1> Next comes Natural Join. Let's say we want to combine attributes from two different relations. So, let's say we want to find e-mail, year, sex, and event. When the birth year of the regular user is the same as the event year of the major 60s events from which these four attributes are poured. So in this case, let's actually take a look at the example instead of looking at the queer expression first. So, what do we want to do here? We want to take the regular user table. We want to take the major 60s event table. Both of those have an attribute year. So, the Natural Join will combine these two tables, we'll just keep a single copy of the column year. When we turn the e-ma-il, the year, the sex, and the event. Now, when is that going to take place? It's going to take place where the year after the regular user matches the year of the major 60s event. So, let's take a look here at the queer expression. So, we are interested in a result that contains: e-mail, year, sex, and event, as you can see here, e-mail, year, sex and event. What must be true for us to generate a tuple in that result? Number one, there must exist a tuple r in regular user. So, down here in this regular use ration, and there must exist a tuple s in the major 60s event. So in other words, our ranges or regular user, and s ranges all major events. The join condition for the natural join is that, the year of r is the same as the year of s, so these two must match. But in addition to that, the email address comes from the email r. The year, we picked that from the year of r. The sex, we picked that from the sex of r. The event, we picked from the event of s. Let's take a look at the first tuple in the result user two. So, user two has birth year 69. Sixty-nine matches, let's see, The moon landing. So, those two tuples get combined in the first tuple in the result. Let's take a look at user three born in 67. Sixty-seven matches this event. The Doors recording of the Alabama Song. So, that becomes part of the tuple. User eight, 68 matches, several tuples. It matches the Tet Offensive year, it matches the Bloody Sunday year, and it matches the MLK assassination year. So, user eight gets combined with all those three events.

<h1>27 - Cartesian Product-CALC</h1> Now let's look at Cartesian product. As you recall Cartesian Product is a very simple way to combine two relations. So, let's say we want to combine every single tuple of the RegularUser relation, with every single tuple of the UserInterests relation. That query is very easy to write. It simply consists of Tuples r followed by s, where r is a tuple in RegularUser, and s is a tuple in UserInterests. So, looking at that again for example user one gets combined with this user one tuple here. So, you see here user one '85 is a male, gets combined with user one, music and 10. Take a look at this tuple here, where does that come from? Well, it's user four '88 and male. So, that's that tuple here gets combined with everything of these tuples here, including the user three, music and 11.

<h1>28 - Cartesian Product-Can be Useful-CALC</h1> Let's say, we want to run an email blast, inviting all users to participate in interest groups for interest they currently don't have. Let's see how we can formulate that in tuple calculus. I actually think it's easier to first explain that on the example here and then look at the expression afterwards. So, what I want to do is I want to combine all emails in RegularUser. I want to combine that with all interests in UserInterests. So, my results are going to have an Email attribute and an Interest attribute. So, that's why the result is structured like this. So, let's see which combinations user1 now gets involved in, so user1 let's combine that with the first interest that's Music, so is user1 and Music part of the result? It appears not. Why is that? Because user1 is already hooked up to Music in the UserInterests. How about user1 hooked up with Blogging. Is that part of the result? Yes, it is. As you see up there, it's in the Result and user1 hooked up with Blogging does not exist down in the current UserInterests. What about user1 hooked up with Meditation? Yes, that's part of the result. It doesn't appear here. What about user1 hooked up with Music? Well, we already talked about that. That appeared up here. So, that doesn't add an extra tuple, so user1 gets hooked up with two additional interests namely, Blogging and Meditation. So, user2 gets hooked up with Music, not with Blogging because it's already here. Not with Meditation because already here and yes with Music, but that's what we started out with. So, User2 is combined with Music. Does user3 get hooked up with Music? No, because user3 is already hooked up with Music. However, user3 does get hooked up with Blogging and Meditation. So, as you see here, user3 is combined with Blogging and Meditation. How about user12? Well, user12 doesn't have any current interest at all. So, user12 gets hooked up with all the interests and they are Music, they are Blogging and they are Meditation and they are Music, but we already did that once and the result is a set. So, now look at the query expression. So, we are looking for Emails, combined with Interests, where r is a tuple in RegularUser and s is a tuple in UserInterests and it is not the case that there exist a tuple t, which is combined from the tuple r and the tuple s.

<h1>29 - Divideby-CALC</h1> Finally, let's look at the Divideby operator. Let's say we want to find emails of all users with at least all the interests of user1. I think it's easiest to take a look at the example here first. So, user1: are we going to return as part of the result the email address of user1? Yes, we are, because user1 certainly does have at least all the interests of user1, namely music, reading, and tennis. So, user1 is part of the result. Is user2 part of the result? Well, we don't even have to think about that because user2 only has two interests. So, user2 cannot both be interest in music, reading, and tennis. How about user3? Well, user3 is a potential candidate. There's one, two, three, four user3 tuples, and so all we got a check now is that user3 has the interest music, reading, and tennis, and it is right here, music, reading, and tennis. So, user3 is part of the result. How about user4? Well, user4 does have three interests but only music and reading match, DIY does not so user4 is not in the result. Let's try to see how we write the calculus expression to do this. So, the first thing we see is we are interested in tuples R with attribute email. So, as you see here, that is the structure of the result. In order for us to consider a particular tuple R to be part of the result, of course, R has to be a tuple in user interests, so in this table here. So, let us consider in turn all of these tuples in user interests. For example, this user3 tuple. For user3 to be in the result it must be the case that for all s' in user interests, either the email is not user1, or if it is user1, then the interests that are here must match up with the interests of the tuple we are asking for in this case. Music, reading, and tennis matches music, reading, and tennis, and that's why user3 is part of the result. So, what you see in this inside expression here is that for all s' in user interest we don't care about the interests that are not hooked up to user1. So, all of these are those that are hooked up to user1, and what this basically says is there must exist a tuple somewhere in the relation that matches the interests of the user1 tuples.

