<h1>6. EER Relational Mapping </h1></br><h1>1 - EER Relational Mapping</h1> You now know the extended entity-relationship model, and you know what a relation is. Next, I'm going to show you, how to map EER diagrams to relations.

<h1>2 - ET</h1> What I'm going to do here and in every single step of the mapping is that to the left, I'm going to show you the extended entity relationship modern notation and to the right, I'm going to show you fragments of the relations that are created by each step of the mapping. So, here the very first and very simple rule we have is, if we have an entity type, give it the name, "ET" then, for that entity type, we create a relation and that relation gets the same name, "ET". If an entity type ET has a property type, single valued property type B, then the relation ET will have B as an attribute. If an entity type ET has a property type A and that property type is an identifying property, then in the relation ET corresponding to it, there will be an attribute A which is an identifying or primary key attribute. So, these steps are very simple. Unfortunately, it gets a little bit more complicated than that. We have an entity type ET with a composite property type C and that composite property type C is composed from property type D and E. Then, in the relation corresponding to ET that adds two attributes, attribute D and attribute E. You might then ask, what happened to property C? Unfortunately, in the translation, property type C gets lost. That means that the meaning that's expressed by the relation will not be as rich as it is here. Vision for example, that C was name and D was first name and E was last name, then and this mapping here you do not really see the concept of name. You only see the concept of first name and last name. So, one could consider the following alternative way of mapping it. It would be nice if in relation ET, the concept C would continue to appear with the two components that it consists of D and E. However, if you remember back to the way we defined a relation, we said that a relation was defined as a subset of tuples that were constructed from domains with atomic values. Now, this would certainly not be a domain with atomic values. This would actually be a domain where we would have a name and two sub-components on it. The relational model is inherently flat and the languages we are going to look, relational algebra, calculus and SQL only work when that's the case. So, unfortunately, this is the solution that we have. We have lost C.

<h1>3 - ET-A-F</h1> The rules for multi-valued property types are quite special. Let's say we have an entity type, ET, and it has an identifying property type, A. Then you know by a previous rule that that results in a relationship, ET will attribute A which is then the primary key. Your multi-valued property type, F, is dealt with for each F as follows. A brand new relation is created. The name of that relation is the name of the entity type, ET-, the name of the particular multi-valued property type we are dealing with, in this case, F. So, the name of the additional relation is ET-F. The property type F results in an attribute in ET-F. Together with that attribute, we insert the identifying property type for ET and then the combination of A and F become a composite key in ET-F. The reason for all of this gymnastics basically is as follows: so, F is multi-valued. We would not be able to just insert F as a property or as an attribute in ET. The reason for that is that we don't have multi values in the relational model. So, we put it in a separate relation together with the identifying property type, A, and make the combination a key. The reason that works is that now, for a given instance of ET, it will have a unique value of A. That unique value of A can now be represented with multiple different values of F as long as the combination of the A and F is unique. That's the reason for the composite key. Of course, the As for which we record F values has to be a subset of the set of As that exist, so the A attribute in ET F will be a foreign key on attribute A in ET.

<h1>4 - ET1-A-ET2</h1> Now, take a look at how we map one-to-one relationship types to the relational model. We already know from our previous rule how to map ET1 with identifying property type A. It becomes relation ET1 with primary key attribute A, similar thing for ET2. Now, in databases, we are going to need to be able to start, for example, with some B values and travel and find the corresponding A values via the relationship type R. So, in relational database, we need to be able to do the same thing. So there are basically two ways of doing that. One way is that in ET1, we insert the primary key attribute of ET2 as a pointer or a reference from ET1 to ET2. Now, I can start out with some A values, find the corresponding B values, go over here, and find them here, and then find whatever ET2 minus to add of information. Alternatively, I could of course take the primary key of ET1 and insert as a reference in ET2 to point back here. Again, this will allow me to travel both ways. So, either the first solution here or the second solution are acceptable. There's one particular situation where we would prefer one of these solutions. Let's take a look at that. Let's say that ET2 has a mandatory participation in relationship type R. What that means is that every single instance of ET2 in the database must be related by relationship R to ET1. That means, in other words, there cannot be an instance of ET2 that's not in a relationship with ET1. In that particular case, it is not advisable to use this solution. The reason being that, since there might be some ET1s that are not related, they will have null values here. This solution is much better because every single one of the ET2s are going to be related to ET1, and therefore there will never be a null value here for that A.

<h1>5 - ET1-R-ET2-1-N</h1> Now, let's take a look at how we map one-to-many relationship types. Let us consider the two different options we had before. In one option, ET1 would be pointing to ET2 and in the other one, ET2 would be pointing to ET1. What would that mean? In a one-to-many relationship type, the instances of the relationship type look as follows. One of those related to many of those, one of those again related to many of those. If we were to choose this first option here, what would that mean? For each instance of ET1 that would obviously be a unique value of A associated with that unique value, there would have to potentially be multiple pointers or references to ET2 just like you can see here. This one needs to reference 2, this one here would need to reference 3. But remember, again, you cannot have multi-valued in A field, in a relation; that was exactly the reason we had to deal in such a strange way with multi-valued attributes. So this solution here having multiple pointers as a value of the attribute, just does not work. What about the other solution, would that still work? Yes, that still works because as you can see, instances on the ET2 side point to a single value on the ET1 side. So it's okay here to insert the ET1 side reference or to ET1 because it's unique for every single value of B. So this solution works, that one is out.

<h1>6 - ET1-R-ET2-N-M</h1> Next comes Many to Many relationship types. How do we deal with those? Well, we already saw before we could not point from the ET1 side to the ET2 side because that would require a multi-valued reference or pointer from ET1 to ET2. So, that one is out. Let's try the other side then. Well, from the other side ET2 you would have to have multiple pointers pointing to the ET1 side and that's not acceptable either. So, that one is out too. So what do we do? Well, here's the solution, instead of just generating one relation for ET1 and one for ET2 as we have correctly done here, we actually need to generate a separate relation for R. So, basically the idea is that from R we will point to the ET1 side and the same for the ET2 side. It is important to notice that it is the combination of attribute A and B that constitute the key of relation R together. Why is that important? Well, it's important because that is exactly what enforces a Many to Many relationship type. It means that for a particular value of A identifying ET1, there will be multiple values of B that are portable and the unique combination is going to identify to plane A and vice versa, for each unique value of B there will be an instance of ET2 that is related to many instances in ET1 and the combination of them is unique.

<h1>7 - ET1-R-A-ET2</h1> Let's now consider how we map identifying relationship types are with weak entity types ET2. ET1 results in a relation ET1 with primary key A. ET2 creates relation ET2 with attribute B. How do we now discriminate between the B values? Well, you know that instances of ET2 needs values of the strong entity types identifier namely A in order to discriminate between them. So, our solution is, to insert in ET2, add reference to ET1 that is the A attribute in ET2 becomes a foreign key on the A attribute in ET1. Somewhat similar to what we saw in the many-to-many relationship type. The combination of A and B here constitute the key for ET2. The reason is as follows. When you look at an instance of ET1 identified by A, then through the one-to-many relationship type here, that will identify multiple values of ET2. Each one of those values has a value of B. So, it takes the A and B in combination to distinguish between the instances of ET2.

<h1>8 - Case 1</h1> Mapping super subtype relationships is a little bit more complicated. There are four cases I would like to consider. In the first case, the relationship between ET and the two subtypes is mandatory. That means that every single instance of ET needs to be hooked up to ET1 or ET2 or both. However, in this particular situation, we are looking at mandatory and disjoint. So, the constraint here is that ET1 and ET2 are disjoint. So, the semantics of this case is the following, every single ET instance will have an A value and a B value. But we also know that every single instance of ET is hooked up either to ET1 or to ET2 as the case might be it's only going to be one of them. Furthermore, we know that when we look ET1, it will inherit attributes A and B, and have C as immediate attribute. When you look at ET2, all values of that will inherit attribute A and B, and have D as immediate attribute. So, in case one, we actually cheat a little bit. We only create a relation for ET1. For ET2, we do not also create a relation for ET. So, ET1 will inherit attributes A and B, and have immediate attribute C that states relation here, of course, the identifier is still A. ET2, similarly, will inherit attribute B and have D as an immediate attribute here. What then you might ask happens to the ET instead are not related to any of those? Well, that can happen because it's mandatory. So, we will in other words, find every single ET instance with a corresponding A and B value, either in ET1 or in ET2.

<h1>9 - Case 2</h1> A slight variation in the interrelationship diagram and actually makes a fairly big difference in the mapping is when the constraint is overlapping. So, in other words, every single instance of ET is either an instance of ET1 or of ET2 or of both. So, the first option, which I really do not like, is an option where we create one single relation. We could call that relation ET. It has attribute A and B. It has attributes C, which is representing the attributes for ET1. One of my attributes, in this case, just D used as an example of the attribute of ET2. Then, it has an attribute called type. Type will say, whether this is an instance that is in ET1 or whether it's an instance that's in ET2 or whether it's an instance that is in both ET1 and ET2. There are several reasons I do not like this option. One is, that when there are instances of ET that is in either.

<h1>10 - Case 3</h1> In case three, ET is not mandatorily related to ET1 and or ET2. ET1 and ET2 are allowed to overlap. Let's take a look at the solution for that. So again this is actually an option, you collect all the attributes together, now you may actually have troupers in this single relay's net has A and B values, but no C or D values because that's not mandatory anymore. For the same reasons as before, I just do not like that. Second solution very similar to the one we used in case two is that we generate a relation for ET, a relation for ET1, and a relation for ET2. Attribute A is inherited in ET1 and ET2 as identifying properties. So, both of those will be foreign keys up to the A attribute in ET. It is now possible to have instances of ET with A and B values where the corresponding A value does not exist in ET1 or ET2 simply because that's not mandatory. It is likewise possible to have instances of ET that are in ET1, for example in this case here, or instances of ET that are in ET2 for example these two relations together. So, this is really a fairly pretty solution.

<h1>11 - Case 4</h1> In Case Four, there is a relationship type, is not mandatory and disjoint. An elegant solution to that is this one. You generate your relations for ET, ET1 and ET2, and of course, ET1 and ET2 will inherit A as an identifying attribute. The reason to this is really a beautiful solution is, that since this is not mandatory, you can have instances of ET that have no corresponding tables in ET1 and ET2. However, when there are tables in ET1 or in ET2 because of the disjointness, a table will only be in one of them. So for an instance here, an instance with a corresponding value will either be an ET1 or an ET2. So there's not even a replication of an A value in the other one that it's not in.

<h1>12 - ET-B-ET1-ET2</h1> Finally, let's look at union type. So ET is a union type. The semantics of that is as follows: ET is a subset of the union of ET1 and ET2, and there's the added constraint that the intersection of ET1 and ET2 is empty. So we know we're going to get a relation for ET1, and we know it has identifying attribute C. We know we will get one for ET2 with identifying attribute D. We know we will have a relation for ET with property type B. The question now is how do we model this subtype relationship here? One way which is sort of a soft hack that works well is the following. We insert an artificial identifier into relation ET. That identifier will then consist either of what corresponds to C or corresponds to D. Remember, that every single element in there comes either from that or from that so it will be identified by C or by D. So the ET identifier is a foreign key on the ET-ID and ET both from ET1 and from ET2.

