<h1>9. Methodology III_ Design (SQL Statements) </h1></br><h1>1 - SQL-Create Table Statements</h1> The next step of the design phase, is to now take this graphical representation of the relations that resulted from mapping, the extended into relationship diagram, together with a format specifications that we created earlier and combined those two, in create table statements that actually define these relations in SQL. Here's the create table statement for the first one of the relations. The user relation, the email is a varchar (50), it is not allowed to be null. Why not? Because you are going to participate in the primary key. Then we have, first name, last name and password these are all varchar (50)s. They are also not allowed to be null but that's because we insist on collecting all that information from every user. The primary key of this relation is email. The SQL syntax for this is simply as stated. Notice that these statements end in a semi colon. So, this is the SQL that will set up this structure, with a data format specified inside the database. Now let's look at the regular user table, it has five attributes; email, birth date, sex, currency and home hometown, email is a varchar (50), it can't be null, because I intend to set it to be the primary key. The property type sex is a single character initially set to null, birth date is order type, date time and initially set to the value null, current city and hometown, are varchar (50)s also set to null. Primary key is email and notice the email of the regular user of course is a foreign key on email of user. So, foreign key email references the email in the user table, direct modeling this relationship. The admin user relation is very simple, email is the primary key, lastlogin is the only attribute initially set to null. The primary key is also a foreign key pointing to email in the user table. So, email in admin user is a foreign key and it references email in the user table. Finally, the interest table has two attributes email and interests. The primary key consists of both, so none of them can be null. Email in addition is a foreign key that points to the email of regular user. Why not to the email of user? Well, the reason is, that it's only the regular users that actually have interests, admin users do not.

<h1>2 - SQL-Create Tables 1</h1> The attend and employment relations are both very complicated. They both stretch, both the capabilities of the relational model and the extended entity relationship diagrams they were mapped from. Let's talk about the attend relation. The attend relation is many to many relationship between regular user and school. So, it comes as no surprise that we need the identifiers for both, to be combined, to identify a row in attend relation. However, adding to the complication, we have a multi-value property type year graduated. And we know that the way that it is modeled is that the thing it is about has a key which is combined with the multi-valued attribute in order to identify each individual value for this particular combination. We, therefore, need an identifier here that consists of three elements. However, the customer requirements that we are working from allows year graduated to be left blank, because no portion of a primary key is allowed to be null. It is not possible to use primary key in the table definition. So I'm using unique instead. So this relation here is going to have email is a varchar (50), school name varchar (50). None of those will be null because then we would not know which relation we are talking about. Year graduated is an integer which initially is set to null, the intent being that a value can later be added when the person has graduated from the school. We use unique instead of primary key to include all of all three. Obviously, both email and school name are foreign keys on the relations that contain the existence of the corresponding entity. Even this way to model things could get us in trouble. For example, if a particular person is working, or two educations at the same time in the same institution, like both are bachelors and a masters in the same university at the same time, then year graduated will be null in both cases.

<h1>3 - SQL-Create Tables 2</h1> The friendship table is created as follows. It has attribute Email and FriendEmail. Both are varchar 50's, none of them can be NULL. The combination of the two is the primary key. The relationship is also varchar 50, NOT NULL, but it is NOT NULL because the value is required not because it's part of the primary key. DateConnected is of the datetime type and initially set to NULL. Email is a foreign key on the Email of RegularUser, and FriendEmail is also a foreign key on the Email of RegularUser.

<h1>4 - Design-on to Abstract Code</h1> We have now completed the first half of the design phase. We started out with an extended entity relationship diagram and some data format specifications, and we use the mapping from the extended entity relationship model to the relational model to create a set of table definitions. So, now we have completed our relational schema definition. We now turn our attention to the tasks. In the specification, the test stated what the application case needs to do relative to the extended entity relationship diagram. In the design, we now need to replace the code that states what the application does to the database with SQL statements that realize that.

<h1>5 - SQL-View Profile 1</h1> Let's first look at the View Profile text, and concentrate on the subtext that retrieves the personal information. So, in other words, we are looking at how to retrieve first name, last name, rest of these personal information items to display on the View Profile screen. We are making the assumption that the email of the current user is managed by the application. So, we are going to retrieve first name, last name, sex, birth date, current city, and hometown for the particular user in question. We do that as follows: here's your SELECT, FROM, WHERE statement. So, we select first name and last name, birth date, sex, current city, and hometown from the user table which contains the first name and the last name. INNER JOIN RegularUser, which of course contains the birth date, sex, current city, and hometown. The INNER JOIN condition is that user email which the application remembers is equal to RegularUser.Email, and that email is the one that the application remembers. That leaves us with the multi-valued attribute interests, and we simply find that with select from interests where the email matches the one that the application remembers. We display those on the form.

<h1>6 - SQL View Profile, part 02</h1> Let us now look at the second subtext of the View Profile text, namely the subtext education. In that subtext, we extract school name, school type, and year graduated. As you see, school name and type are in the school table; year graduated is in the attend table. So, we need to proceed as follows. We take the score table and join it with the attend table on matching school names and then we extract where the email is the email of the current user. So, let's look at the SQL for that. We select School.SchoolName and School.Type and we select Attend.YearGraduated and we do it by taking the attend table and doing an INNER JOIN with schoool and the join condition is that the two school names match. School name must match school name, and we extract where the email matches that of the current user. Finally, extracting the professional information consisting of employer name and job title is done from the employment table. So, we select employer name and job title from employment where the email is that of the current user and we display that information here.

<h1>7 - SQL Edit Profile, part 01</h1> The Edit Profile task has four sub tasks. View Profile, which we just completed, Update Personal Information, Add or Delete a School, Add or Delete an Employer. The first step is to populate the dropdowns namely, School Name and Employer Name. So, those dropdowns here, to populate those, we need to do a selection from the set of school names and a set of employer names that currently exist. So, each one of the SQL statements for that are here. SELECT SchoolName and Type FROM School, SELECT EmployerName FROM Employer. Now to update the personal information, we continue to assume that the email of the current user is managed by the application. We then read Sex, Birthdate, CurrentCity and Hometown from the input fields on the personal information portion of the Profile screen. So, having read those, we now update the RegularUser and we overwrite the Sex with a new value, the Birthdate with a new value, CurrentCity, and Hometown with a new value and we do it for the row that has an Email address that matches the Email of the current user. For each one of the Interest that's added, we insert into the Interest table the Email of the current user, and the interest.

<h1>8 - SQL Edit Profile, part 02</h1> If the user clicks "Delete this School," then we delete from Attend where the email matches the email of the current user. The school name matches the school name identified to be deleted, and the year graduated matches the year graduated of the school that has been identified to be deleted. If a new school is added with a school name given here and a year graduated given here that will be done by an insertion into the Attend's table of email, school name, and year graduated, where the values are the email of the current user, the school name read from input, and the year graduated read from input. To update an existing school, we need to make the assumption that the application manages the old school name and the old year graduated. To overwrite those with the new values of school name and year graduated, we need an update statement. Update Attends will set the school name to the new value and the year graduated to the new value where the following is true, namely the email equals the email of the current user, the school name is the old name, and the year graduated is the old year.

<h1>9 - SQL Edit Profile, part 03</h1> Let's finally look at how to add and delete employers for particular regular user. On the screen, we will have identified the EmployerName and JobTitle that need to be deleted. The following SQL statement will do the deletion. Delete from employment where the Email matches that of the current user and the EmployerName is that on the screen and the JobTitle is that on the screen. If we are adding a new job where the value of the EmployerName and JobTitle are given in the text fields on the screen, then the following statement will do that addition of the job. Insert into Employment, Email, EmployerName, and JobTitle, where the values are the Email of the current user, the EmployerName written in the text box, and the JobTitle written in the text box. To update an existing job, we will assume that the application manages OldEmployerName and OldJobTitle. The following update employment statement will replace the old values by the two new values. So, update employment, set EmployerName to the new one, set JobTitle to the new one, where the Email is that of the current user, and the EmployerName currently is the OldEmployerName, and the JobTitle currently the OldJobTitle.

<h1>10 - SQL Request Friend</h1> Let's look at how requesting a friendship is done through an insertion into the friendship table. As before, we assume that the application knows the e-mail of the current user. It will also know the e-mail of the friend that's being requested through a user click on the screen, and the relationship will be input by the user that's making the request. With that information, this is the insertion. So, insert into the friendship table, and e-mail, a friends e-mail, and date connected and a relationship. The values the following; the e-mail of the current user, the friend email identified there, the null value for date connected, because this invitation has not yet been accepted, and then the value of relationship read from the screen.

<h1>11 - SQL View Requests</h1> Let's look at the subtask view pending requests. There are two kinds of pending requests; pending requests to you and pending requests from you. Let's concentrate on pending requests to you first. When it's a pending request to you, you know that in the friendship table, the friend email in this case, is your email. The one requesting you to become friends has this email. To collect the information about the requestor, you need a three-way join that puts together the first name, last name, birthday, sex etc. to the email of the person that requests you to become friends. This three-way join is illustrated here. So, you join friendship, RegularUser and user and it's all on matching emails. That email matches this one, matches this one. Now, you got one big table with all this information in it. Their particular row you want to extract in that table is the row where their friends email is your email as current user, and date connected is null because it's still pending. So, now you've got that one row. From that you can now extract from the requester the email, the first name, the last name, hometown, relationship etc. When the request is from you, you know the following, the email in the friendship table is your email. To pull together all the information about the other user you have requested to be friends with, you need to match the user email, the regular user email to the friends email, and that is exactly what is done in this three-way join here.

<h1>12 - SQL Accept, Reject, Cancel Friend Requests</h1> If you decide to reject a request, then the road to look for is the one where friend's email is your email, and the email is that of the person that requested you to become friends. So, delete from friendship where the email is the value of friend's email and the friend email, is your email is going to do the trick. Now, if you decide to accept a request, and the time is now, then this update will do it. You update the friendship table and you set date connected to now, where the friend email is yours and the email is that of the requestor. Finally, if you decide to click cancel, and cancel a request that you have made, then the following SQL statement is going to delete the appropriate row. Delete from friendship where the email equals your email as current user, and a friend email equals the value of the friend email identified on the form.

<h1>13 - Design on to Abstract Code w SQL</h1> So, we have now completed the data first portion of the design phase of the database application development methodology. We took the extended interrelationship diagram, used the mapping to generate a set of relations. We check that the relations are in the proper Boyce-Codd normal form. Now, the next step is to take a look at the tasks that we specified in the specification process. Those tasks express what tests of the application will do relative to the extended interrelationship diagram. Now, that we have translated that diagram into a set of relations, we need to adjust the task to do to the relations what they previously did to the extended interrelationship diagram. So, in the abstract code for the task, we need the code to work on the relational schema as opposed to the extended interrelationship diagram. So, let's now dive into that step of the design phase.

