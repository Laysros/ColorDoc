<h1>5. Methodology II- SPECIFICATION </h1></br><h1>1 - Requirements 06 - </h1> Let's first look at these two documents, the login screen and the registration screen. And here's one of the requirements from the customer from whom we're building the application. The requirement says all users are uniquely identified by his or her email address, what does that tell us? Well, it tells us that there's an entity type of users and that users are identified by email addresses. It also tells us something about the processes, namely that email address and password in combination will log the user into the system. That means there also is an attribute of password. So the first piece of the extended entity relationship diagram models users as an entity type, with attributes email and password, where email is a unique identifier for the user, and therefore we have underlined it as an identifying attribute. On the registration screen we also have a first name and a last name. I've chose to include a composite attribute name that has first and last name as components. Strictly speaking, this actually models this situation here, where there's a name field which is composite consisting of first name and last name. I have chosen to specify it like this though.

<h1>2 - Use Attribute names - </h1> From the edit profile screen, we see that several additional attributes are needed. Sex, Birthdate, Current City, and Hometown, are all single value property types. Interests is a multi-value property type modeled here by the double ellipses. Notice that I'm very, very careful to use the names that are provided on the documents in my EER diagram. That way, I tie the diagram very, very closely to the real world. The idea is that the entity relationship diagram really becomes a high quality model of reality. Reality represented by the documents that people of the application use.

<h1>3 - Requirements 07 - </h1> Here's one more requirement for the cosmos we're building the application for. It's says that all GT online users except admin users have a profile. What did we learn from that? We learned that they are not just users. They are also admin users. The way we specify that is as follows. The users actually has two subtypes. It has regular users and admin users. The regular users are those that have this additional information in their profile whereas admin users do not. An additional requirement from the customer says that administrative users have some of the same information as regular users, namely e-mail address, password, first name, and last name. So it is okay to keep those as properties of user in general. Since both regular users and admin users have them, they would then be able to inherit those properties from the super type user. It is also further specified here that the admin users do not have all the other properties that are in the profile of regular users. Then it says a user must be either an administrator or a regular user. That must, is reflected by the mandatory relationship here. And it says the user must be either an administrator or a regular user, but never both. That means that the constraint here on the super sub type is a disjointness constraint. The only additional attribute an admin user has, other than those inherited from a user, is that of the last login date and time.

<h1>4 - Requirements 08 - </h1> Looking further down the edit profile screen, we see the education section of it. Looking at the requirements from our customer is a snippet, says a list of schools from which the user can select is maintained by the system administrator. So in other words, we have a list of schools as an entity type in the database. Further says that school names are unique, that means that school name is an identifying attribute of school. It says that user can have any number of schools associated with him or her. So that means for a particular user, many schools can be associated with that user. Of course, for a particular school there may be many regular users who have attended that school, so given one school there may be many regular users associated with that school. In a unique relationship instance between a regular user and a school, there's year graduated date associated with it. Since a regular user may attempt the same school for many different levels of education, like bachelors and masters, for example, the year graduated is a multi-value. So here's the screen that an admin user uses to maintain a list of schools and their types. Each school must have a school type. So the relationship here is mandatory. A school type, of course, can be the type from any schools on the list.

<h1>5 - Requirements 08.1 - </h1> So at the bottom of the Edit Profile screen, is the Professional section. Just like a regular user can have attended multiple schools, a regular user may have had several employers. Here you see the screen that the admin user uses to maintain a list of employers. So, we have an entity type of Employer. Employers have the property type Employer Name, and Employer Names are unique. As we saw from the Edit Profile screen, a regular user may have had multiple employers over time, and, obviously, a particular employer may have multiple regular users working for that employer. Job title is not maintained by the administrative user. It can be anything that the regular user wants to insert. It's a multi-value, because over time a particular regular user may have held different job titles for the same employer.

<h1>6 - Requirements 09 - </h1> Let's look at the two screens that are used to request and accept friendships. So a particular user can request multiple other users to be friends. For each one of those requests, there is an instance of the request relationship. So one regular user may have requested several different friendships. In the pending request here, the list of people who have requested to be friends with you. Here is the list of people that you have requested as friends. When a user accepts a request, that adds an instance to the accept relationship. So a particular regular user may have accepted requests for friendships from multiple different users. The date connected records the date that the invitation was accepted. Notice in this requirement it's very interesting that friendship here is not always reciprocal. Just because Emily is a friend with Sarah, does not necessarily imply that Sarah is a friend with Emily.

<h1>7 - EER Mapping - </h1> Adding it all together, here is the EER diagram we have arrived at. We have a set of users. The users are uniquely identified by email. Users have passwords and they have names that are composed from first and last names. A user must either be a regular user or an admin user, but cannot be both. Therefore, the constraint is disjoint. Regular users have profiles with sex, birthdate, current city, and hometown, and a list of interests. Admin users only have a single property name the last time they logged in. Regular users may have attended multiple schools. And a particular school may have multiple regular users that attended it. A school must have a school type. Schools are identified by school name, school type identified by type name. A regular user may have worked for many employers and a particular employer of course may have many regular users working for that employer. A particular employer could hold multiple titles over time for the same employer. Employee names are unique. You have the friendships. Regular users request multiple friendships. And regular users can accept multiple friendships. Date connected reflects the date that our friendship request was accepted.

<h1>8 - Reading EER Diagrams - </h1> Please notice that the way I just summarized that extended entity relationship diagram was quite mechanical in nature. It would actually be possible to write a program that would take as input and extend it into relationship diagram and then read out in English exactly what it means. No more, no less. When you are talking with your customer about your database specification, they will not be able to understand the extended entity relationship diagram. They might be able able to understand this English representation of that diagram. Of course we all understand that when reading this, you need to pay very very careful attention to every single word that's in that description.

<h1>9 - Data Formats-beg, steal, borrow - </h1> Now that we have used the input and output documents for the application to help us with the specification of the database in terms of an extended entity relationship diagram, let us take a look at what kind of data formats are going to be needed. We're going to take a look at the documents that are input to or output from the data base because whichever format it is that's required for those, corresponding formats will eventually be needed to represent property types inside a relational data base. So looking, for example, at the user entity type, let's talk about some of the property type. So email could, for example, be 36 characters. Here's an example of that. A password could be maximum 20 characters. There might also be a restriction on how short it's allowed to be. A first name could be 25 characters, last name 40. Addresses, when needed, are very, very difficult to deal with. A couple of years ago when I was looking at address formats, I ran into the United States Postal Service's recommendation for addresses across the world. It's a whopping 200+ page guideline. Guidelines like that take specialists to develop, and it takes a lot of time. Instead of every single database designer out there who needs to create addresses in their database, maybe they should take a look at what other people have done. In general, you can extrapolate that idea into one of the basic concepts when it comes to data formatting, namely beg, steal, and borrow. If someone already has spent a lot of time thinking about this, why would you do it, too? Continuing, for the regular user, some examples could be birthdate might have this format. Sex might have this. Current city hometown may have, say, 20 characters, interest and multi-value attribute with 16 characters per each one of the values in the multi-value. To determine what the data format should be, you will need to look at the input and output documents, and you might need to consult with a customer to ask what their needs are. That detail was not specified in the description that you read previously.

<h1>10 - Constraints - </h1> Having now addressed the data formats of the property types, lets talk about constraints. Here are some examples of constraints in the particular application we are creating now. For example, DateConnected must be NULL until a friend's request has been accepted. Another example is you cannot be friend with yourself. So whenever there is an insertion into the database to establish a friendship, the application needs to check that this constraint is not violated. You could have a constraint saying that only comments on the status of friends is allowed. In other words, if you try to submit a comment on a person that is not your friend, then the application system should reject that. To be a little bit more specific about the kind of constraints we are looking for, remember we have already expressed constraints in the Extended Entity Relationship diagram. And by specifying what the data formatting would be, we should not include those on the constraints. So where does that leave us? Well, it basically leaves us with a set of rules that we can describe in the database that we can't format our way out of. So there's only one place left to do it and that is to program it into the application program so that constraints like this are enforced.

<h1>11 - Task Decomposition - </h1> Having now addressed the structural aspect of the specification, let us look at the specification of tasks. So for each one of the tasks we identified in the information flow diagram, we need to talk about whether that's a single task or whether it should be decomposed. The rules of thumb I'm going to give you are based on a deep understanding of the internal workings of a database management system. In each one of the cases I'm going to give you the rule, and I'm going to tell you what it is based on. Later on when you do task decomposition, you're going to go through these rules that I'm giving you in order to determine whether the particular task you're looking at should be decomposed or not. So from a database management system perspective, there's a big difference between whether a task just is a look up task or whether it actually modifies the database through an insertion, deletion, or update. The reason for that is that different database locks are needed in order to support lookups versus changes to the database. So if many different things take place, then that's a indication that the test should be decomposed. The second rule of thumb is based on how big a portion of the database is involved in the operation. The bigger the portion is, the harder it is to acquire all the logs that are needed in order to support concurrent execution of transactions on the database. So if a large number of schema constructs are involved, that would make you want to decompose the task into smaller tasks using smaller portions of the database. The next rule of thumb is based on what enables the different portions of a task. So if some portion of a task are enabled, then why not let those proceed instead of waiting to later on when there might not be resource available to run those tasks that were earlier enabled. The smaller portions of a task that can run, the easier it is to schedule the task. The next rule of thumb is based on what the frequencies of the things that are done by the task are. If the task contains things that are done with a high frequency and things that are done with a low frequency, it is a good idea to split them apart. The reason is that high frequency things, you want to index to run fast. Whereas low frequency things, you may not need to index. The next really important rule of thumb is related to consistency of the database. Is it really essential that all the pieces of a task get done in one transaction? Or is it okay that things get spread out a little bit over time? An example of that would be transferring money from one bank account to another one. So it is very important that all the steps involved are done together. For example, monies must be available in the from account. They must be subtracted from the balance of the from account, and they must be deposited into the to account. All of those things must be done together, in order that you do not end up with an inconsistent database. The final rule of thumb is based on the question of whether a mother task is needed to control subtasks. Sometimes you need a mother task, sometimes you do not. The banking example I just gave you certainly needs a mother task. We're later going to see things that may not need a mother task.

<h1>12 - Web apps vs Traditional apps - </h1> Before we look at some examples of tests decompensation, let us briefly talk about web based applications, versus traditional applications. Web based applications are almost completely stateless. The amount of state may be as little at the login information for a session user. There may be a small amount of click stream data that's available in order to proceed with the application. Things, however, for web-based applications are changing. With new technologies such as Web 2.0 and AJAX it is now possible to provide much more state with the application. Because of that web applications are beginning to act more like traditional applications. What is it we have been able to do with traditional applications? Well, in a traditional application, it is much easier to manage local states separate from the database. That means that a whole bunch of changes can be collected, before they are submitted to the Database Management System for execution. That means, that there is not a roundtrip to the database needed every single time a minor thing is changed. So it's as you have to do in a web app. Traditionally applications are much better to support control of ACID transaction properties, so that's a big advantage too. So fortunately, web app technology is moving closer to traditional app technology. An understanding of this is necessary as we consider examples of tasty composition.

<h1>13 - Task Decomposition-View Profile v2 - </h1> So as our first example of Task Decomposition, let's now try to use our rules of thumb. On the View Profile test, which is the test that supports the View Profile screen. So by looking at the screen here, we notice that there are three lookups. There's a lookup of the personal information. There's a lookup of the education information, and finally the professional information for a regular user. All three lookups are read-only. In other words, there's no operation or update of the database that takes place. All three are enabled by a user's login or a friend's lookup. All three have the same frequency. A fairly large number of schema constructs are needed for this task. Just look in the EER diagram and see how big a portion the personal information covers the education information and the professional information. Consistency is really not critical. So even if there is an update going on here on the database by some other user, whether you get the absolute 100% up to date version of the personal information, the education information, and professional information is not really important. Another important observation is, that these can be done in any order. They do not need to be done in the order of personal, then education, then professional information. So there's flexibility in the order of execution. However all three of the must be done in order to display the information on the View Profile screen. So another task is needed to make sure that all three things get done. Most of these are good indicators that the task should be split up in three subtasks. So we take the View Profile task and split it up in the View Personal, View Education, and View Professional

<h1>14 - Abstract Code-View Profile v2 - </h1> So the first step is to find the current user using User Email. We can now, having found that user, we can display on the output document View Profile the name of the user. Again, using the User Email we can now move down and check the RegularUser entity type and by looking at the property types here we are then able to display Sex, BirthDate, CurrentCity, Hometown and Interests. That takes care of the personal information. Now we gotta go through each school the user has attended and display that information and each job the user has had and display that information. So let's first take a look at the school information. So we start with a RegularUser and that leads us to N number of schools that the user has attended. So for each one of those, display the school name and the year graduated. Find the SchoolType and display that. For each employer, start with a RegularUser, find the N employers that that RegularUser has worked for. And for each one of them, display the EmployerName and the JobTitle. So that's the abstract code, there is no formal syntax for abstract code. Every one has his or her own style. But this is fairly formal and fairly precise and fairly complete description of what needs to take place for each one of these subsets here. And it is sort of the penultimate step before writing this in SQL on a real relational database when we get that far.

<h1>15 - Task Decomposition-Edit Profile v2 - </h1> Now let's take a second example and look at test decomposition for the edit profile page. Here is the document which is both an input and output document that needs to be supported by the edit profile task. This is somewhat more complicated than the view profile task. Let us first check the rule of thumb for decomposition for this task. The first step in the edit profile task is a lookup of personal education and professional information in order to be able to support editing it. Now, fortunately we just specified the view profile task, so we're going to use that for that. So that takes care of that step. In order to populate the edit profile screen, it is necessary for us to go to the database and look up the list of schools and the list of employers. Without those we won't be able to populate the drop down menus. The added profile task may end up editing any one of the three groups of information. The personal, the educational, and the professional information. Both reading from the database and writing to the database are possible in the edit profile task. Reading for example, to look up the list of schools and employers. And writing could take place in order to execute an insertion, a deletion, or an update. Certainly insertion is possible if an extra school is added to the education section. Deletion is possible if one of them is removed. An update is possible if information has changed, for example, in the personal information section. The only thing that's required in order to enable one of these operations is the users login and then separate edit requests. As you can see, there's a separate save here. There's a separate add and save here. Separate add and save here. The frequencies of the things that happen in this task are somewhat different. Some of the information will not change, like sex and birthdate. Current city might. Interest might change overtime. The education won't change that many times, but your job history may change overtime. These are not great differences in frequency but there are differences. Clearly there are several different schema constructs involved. There's both the personal information portion for user and for regular user. There's the whole education portion. And there's the whole professional portion. Again, consistency is not necessarily critical. If someone else is looking up this profile that the owner of the profile is currently updating, it is not essential that the absolute up to the second latest version is available. There's some sequencing of what needs to take place, so the lookup or the read to the database of course needs to be done first. And then followed by any number of edits or additional lookups. A model task is clearly needed for this. This task should be decomposed into a set of subtasks. So the edit profile task should be subdivided into view profile that's read only. Update the personal information. Add and delete schools. Add and delete jobs. This subtask will update only the regular user information. This one could update both regular user and school. Likewise, this one could update both regular user and employer information. So, as we did in our first example, our job is now to describe the abstract code that's going to make this happen. And the idea is to say how each of these are going to take place, which will tie this input output document that sits outside of the system boundary, through the task edit profile, to the database.

<h1>16 - Abstract Code-Edit Profile v2 - </h1> The first step of the task is to execute the View Profile task. That task will populate the School and Employer drop down lists. The next step is to sit back and do nothing. As long as no one pushes one of the buttons to add or delete or save, we don't need to do anything. So sit around, do nothing. When a button is pushed, then do the following. If the button that's pushed is the Save Personal Information, then update the personal information and run View Profile again as you did in the beginning in order to display the new state. If it's the Delete This School button that's pushed, then delete the school and run View Profile to redisplay the screen. If it's Delete This Job, then delete the job, run the View Profile to redisplay the screen. If it's the Add Another School button that's pushed, then, one, View Profile again and display the added profile screen with room to add another school. If it's Add Another Job button that's pushed, then run View Profile again, redisplay the edit profile screen with room to add another job. If the Save School button is pushed, then add the school to the database, rerun View Profile, and redisplay the edit profile screen. If it's the save job button that's pushed, then add the job, rerun view profile to redisplay the edit profile screen. Finally, if the Cancel button is pushed, then run View Profile for the current user and display that screen. In this and the previous example, I've used the following notation. I used bold, underline for the task definition. I use bold for task calls, so it says View Profile. I use italics for names of buttons, such as Delete This School, Delete This job, etc.

<h1>17 - Task Decomposition Friend Requests v2 - </h1> Without going into the same level of detail as I did with the first two examples. Let's take a look at test decomposition for friend requests. The idea gain is that we have the forms that are the interface to the application. And our job is to now talk about the decomposition of the tests that are necessary in order to tie these forms through the task into the database. If we did a closer analysis using the rule of thumb for task decomposition for this task we would arrive at the following result. The request friend test would be separate from the others. This task would update the database with a request and would support this form. The view, cancel, accept, and reject request task is the one that supports this form, and supports actions taken to the requests that are pending. It would end up being decomposed in two subtasks, view the request and then support the accept, reject, and cancel options. This subtask would update the friendship relationship type. This task would support the reading of user and regular user and friendship information.

<h1>18 - Specification - </h1> This basically complete the specification phase of our database development methodology. We have generated an extended energy relationship diagram, we have looked at data formats, and we have looked at constraints. And based on that, we then looked at the test decomposition and wrote abstract code for the tasks. We now need to take a little detour. When we come back again, we're going to proceed with a design. In the design, we're going to translate the extended relationship diagram to a Relational Database Schema. And we're going to take the abstract code for the test and put in the SQL that is necessary, in order for the test to do to the relational database, what our abstract code did to the extended entity relationship diagram.

<h1>19 - DETOUR_ ERR MAPPING - </h1> Before we go any further, we need a small detour to study an additional database tool or technique

