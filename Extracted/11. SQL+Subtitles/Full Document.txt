<h1>11. SQL </h1></br><h1>1 - (headshot) SQL Introduction</h1> So, now we get to SQL. SQL is sort of the lingua franca of databases. Most databases support some form of SQL. Mike Stonebraker also called SQL, the intergalactic data speak some years ago, and that is really still true. Most data sit in relational databases and are accessed through SQL. Although, XML is used quite a lot to describe interfaces and to exchange data, the real data still sit in SQL databases. So, now on to SQL.

<h1>2 - SQL History v2</h1> Let me give you a brief history of SQL or Sequel as many people call it. SQL was actually the original name standing for Structured English Query Language. SQL was part of System R which was a research relation database prototype released by IBM in 1973. SQL was created by Chamberlin and Boyce. So, name was changed to SQL which stands for Structured Query Language. SQL is based on relational tuple calculus and some algebra. By the way, do you know what mermaid's square? Algebra. They are both ANSI and ISO standards for SQL. SQL1, first version was standardized in '86, and then a revision in '89, what is now we referred to as SQL2, was published in '92, and in '99 followed SQL3. There have been a number of revisions here every two to three years since then. In most of the cases, the fundamental part of SQL is as good with a standard is the same, but these revisions have added a lot of functionality for temporal queries, spatial queries, and other things. SQL is supported by a large, large number of database products. IBMs, DB2 which was actually a commercial version of System R, Oracle, Sybase, SQL Server, MySQL, and many, many more, and they all support the standard SQL or they do that. We'll get back to that.

<h1>3 - Insert</h1> So let's first look at an example of insert. So this insertion here inserts into user interests a table with the values user12@gt.edu, reading and five as the values of e-mail interest and the since age. So if you start out with a user interest table like this, then after the insertion, the user12@gt.edu reading and five will have been added. It's interesting to observe that inserting into the database will only insert a single row at a time, unless the insertion contains a clear expression on the database that identifies some data from the database itself and insert it in one of the tables in the database.

<h1>4 - Delete</h1> Second, let's take a look at deletion. So, this expression here will DELETE FROM UserInterests, WHERE the Interest equals Swimming. So, all the tuples that satisfy that condition, this tuple here and this tuple here will be removed. So, the result is this. So, notice a deletion can actually result in deleting a set of rows in the table.

<h1>5 - Update</h1> Let's now look at update. So, UPDATE UserInterests or right and SET Interest attribute to rock music where the e-mail in that row is user three and the interest is music. This row here is the only one that satisfies the condition, that its user three and the interest is music. So, this row here will be updated and the new value will be user3@gt.edu, rock music and 11. Notice that a set update is possible in an update expression.

<h1>7 - Selection-Wildcard</h1> Let's first look at a very simple selection query. Let's say, we simply want to find all the rows in regular user. Here's one way to write then. SELECT Email, BirthYear, Sex, CurrentCity, HomeTown FROM RegularUser. Notice there's no way I'm closing this query. Notice also, that all the SQL queries they end with a semicolon. So basically what we are saying here is give me all the attributes: email, birth year, sex, current city and hometown from the regular user table. And what is the result going to be? Well of course, it's going to be all the rows in the regular user table. There's an easier way to write that by using the wildcard star. So, SELECT star actually is the exact same query as the one you see there. It makes it a little bit easier to type.

<h1>8 - Selection-Where clause</h1> Let's now try a selection that actually has a WHERE clause. Let's say we want to find all RegularUser's with a Hometown equal Atlanta. Queries as follows, select everything, in other words all the columns FROM RegularUser WHERE the Hometown equals Atlanta. So from the RegularUser table WHERE is Hometown equal to Atlanta. So it is here for you user one, so that row is part of the table, it is for user four, which will appear in the result and is for user six, which is part of the result. What I'm trying to do in these examples and examples to follow is I'm trying to tie my English text very close to the names used in relations, in attributes, in columns etc. etc. So, when I write something like this "Find all RegularUsers with hometown Atlanta", this is not of course correct English, I'm doing it because at the same time I want to point to the RegularUser table so I had a choice between doing something like this RegularUser's or just say find all RegularUser with Hometown Atlanta, but that wouldn't sound right in English either. So this is what I chose.

<h1>9 - Selection-Composite Where clause</h1> Looking at a selection with a composite where clause. Let's say, we want to find all regular users who either have the same CurrenCity and HomeTown or who live in Atlanta. The rescue out for that would be as follows: select all the columns from regular user, where either the CurrentCity equal HomeTown or HomeTown equal Atlanta. So, let's take a look at the regular user table. Does the HomeTown equal Atlanta? Yes it does. So, user one is part of the result. Are CurrentCity and HomeTown the same? No. Does HomeTown equal Atlanta? No. So, user three is not part of the result. Is user 4? Yes. Is user 6? Yes. So, starting out with this table this is your result.

<h1>10 - Projection</h1> Let's look at a projection now. Let's say, we want to find just some of the columns of the regular user table, namely email, birth year, and sex for regular users in Atlanta. So, it is a projection. We can't use to star wild card. It is a projection on only some of the columns of the regular user table. So, in other words, the result from this query here is going to have three columns, e-mail, birth year, and sex in that order. So, going through then the regular user table, we're going to have to look at where hometown equals Atlanta. It does here, so that means that user1, 85 and male is at row in the result. User4 hometown is Atlanta, so user4, 88, and male is in the result. Finally, user6, 88 female is in the result.

<h1>11 - Distinct</h1> When we looked at Relational Algebra and Calculus I emphasized many many times that relations are sets, and that the result of a query is always a relation and therefore, a set. In SQL, tables may have duplicate rows. Let me talk about the keyword 'Distinct'. So let's say I want to find a sex for regular users in Atlanta. The query to do that is as follows. SELECT sex, FROM RegularUser, WHERE HomeTown equals 'Atlanta'. Looking at the RegularUser table and the rows where HomeTown equals Atlanta, you see that user one satisfies that. So, male is part of the result. So is male a second time for user four and so is female for user six. So here, male appears twice. If you want to avoid the duplication, here's the way to do that. You use the keyword Distinct around the attribute that you want returned. So, in this case, the result is the same except duplicates are eliminated. So, you get just the row male and female returned.

<h1>13 - Natural Inner Join-aliases</h1> Let me use the same example I just used for natural inner join to show you the important concept of aliases. So as before, you want to find Email, BirthYear, and Salary for RegularUsers who have a Salary. We want to do that by combining the RegularUser data with the YearSalary data. So, an alternative way of writing that query is as follows: We're going to involve two tables, RegularUser and YearSalary. But notice here that for the purpose of this query, for the scope of this query, instead of calling it RegularUser, we are using the alias R instead. Instead of calling it YearSalary, we are using the alias Y. Now, within this query from the first SELECT, we can now use R and Y instead of RegularUser and YearSalary. So up here in the SELECT line, we're going to select Email and R.BirthYear, Salary, and the condition is that R.BirthYear equals Y.BirthYear. So the idea here behind the query then is as follows, and this is why this is a very interesting query and why aliases are important. So remember in the Tuple calculus, we worked with Tuple variables. R and Y, in this case, are exactly Tuple variables. So when we introduce R here to range over RegularUser, think about it as R taking on the value of each one of these rows in turn joined the query evaluation. Similarly with Y, we'll take on these row values one at a time, and then for each pair starts S. For example, user1@gt.edu, '85, male is one instantiation of that, here's an instantiation of the YearSalary alias Y they combine here and therefore they create this Tuple here. So that's the whole idea, R and Y are Tuple variables. There are some other advantages, of course, it saves typing; some SQL queries get really, really long. If you have ROLLUP queries, they could be several pages of print out text. One important thing that aliases are also used for is to disambiguate table references. In particular, aliases must be used if you join a table with itself so you can disambiguate between the first of two tables in the join and the second one of the tables in the join. I strongly recommend using aliases when you write queries. it's just a great way to think, and you are then aided in your understanding by thinking Tuple calculus.

<h1>14 - Left Outer Join</h1> Let's see how we do the left outer JOIN in SQL. So, the example we used was find email, birth year, and salary for regular users who have a salary by combining regular user data and year's salary data, but return email and birth even when the regular user has no salary. It's called an outer JOIN because as opposed to an inner JOIN, the only tuples from a regular user and year salary that would be combined are those that actually match up on the JOIN condition. So, here's how you write that query in SQL. Select email regularuser.BirthYear,Salary from regular user left outer JOIN year salary. Notice again, that algebra has snogged into this query. You get user1 here combined through matching years. The first table you get user2 combined through the 69 for this result. You get user3 matching 67 to give the third row in the result. But, now look, user4, six, eight, and nine, the years do not match birth year of year salary. So therefore, for those four last tuples, we do get user4 and 88, but there is no salary to match a doc with. So, in each one of those cases a null value is put in.

<h1>15 - String Matching</h1> Until now, most of the SQL questions we have looked at have been just SQL versions of relational algebra queries. There was one exception and that was distinct. So, SQL databases are real practical tools. They need to have capabilities that you have not seen before in relational algebra and calculus. The second one of those is a string matching capability. So, consider a query like this; find data about RegularUsers who live in a CurrentCity that starts with San and is followed by something. Here's how you write that in SQL. Select Email, Sex, CurrentCity from RegularUser, where CurrentCity is like San % sign. So, % sign will match any string. That actually, includes the empty string. So, San % sign is going to match San and it's going to match San followed by anything of any length. So, let's take a look at that query. What is the result going to be? So, it's on CurrentCity and we are going to return Email, Sex and CurrentCity but only if the beginning of the CurrentCity matches San. So, that's certainly not the case for Seattle. It's certainly the case for San Diego, starts with San, ends with Diego. So, user3 with sex male, and CurrentCity San Diego, is part of the answer to the query. User4 , San Francisco, same thing. User6, San Diego, is part of the result. Las Vegas, no. College park, no. There are more types of wildcards. Don't confuse these wildcards with the style wildcard we use in this select line to select all attributes. So, this one here matches the front and you can follow by % sign. You could put that % in other places too. Here's a somewhat different one. This one says, select Email, Sex, HomeTown from RegularUser, where the HomeTown is like A followed by underscore, underscore, underscore, underscore underscore. Five underscores. Each one of these underscores will match exactly one character. So, we are in other words looking for RegularUsers that have a HomeTowns that start with A and are followed by five additional characters. So, is that the case with Atlanta? No. It starts with A, but then there are six additional characters. Fourth and forget about it. Atlanta, Atlanta, Atlanta. Austin starts with A, followed by 5 characters. So, user12 who has HomeTown Austin qualifies in the result.

<h1>16 - Sorting</h1> Sorting, oh no. Another one of those practical things. But if you print out from an SQL query, say a phone number list, don't you want that sorted by say, last name? So from a practical perspective, although it's not part of algebra and calculus, you do need ability to sort an output. Let's say you want to find data about regular users who are males, and you want to sort the data by ascending current city. So, we select emails, sex, and currency city from regular user for males and we order the result by current city ascending. So, what is the result going to look like? Well, it's only the males that are involved here. So, this tuple is going to qualify, this tuple is going to qualify, this one, and this one. So, we know there are four tuples in the result. Now, it needs to be sorted by current city. So, the first output will be the row Austin, then San Diego, then San Francisco, and finally Seattle. It is possible to sort on multiple columns. You can sort ascending and or descending.

<h1>17 - Set Operations-Union</h1> Now, let's see how you would do an operation corresponding to an algebra Union in SQL. Actually, now, we have gotten so used to algebra being involved in many SQL queries, I'm not even gonna sound that alarm for you anymore. So let's say you want to find all current cities in hometowns without duplicate. How do we do that? Well, we do one query that says select currency from regular user, do another query that says select hometown from regular user, and we say Union between them. Does not get much simpler than that. So basically, here, it's a projection on current city and from the same table, it's a projection on home town and then it's the set Union of the two, and notice in this case here that there are no duplicates. So where as SQL queries in general may return duplicates? The semantics of the Union intersection and set difference operators is that sets are returned. In case you do want to see cities as many times as they occur, here is the way to do that. Instead of saying Union, as you do over there, you say Union All, same query. In this case, here in the Union All result, you will get one, two, three, four, five, six, seven, eight, nine, 10 rows in your result, and that will of course include some duplicates like Atlanta, just as hometown, is here three times. So you're going to see Atlanta three times in this result. Union All is what makes that [inaudible].

<h1>18 - Set Operations-Intersect</h1> Now, let's look at intersection in SQL. So, let's say we want to find all cities that are CurrentCity's for someone and HomeTown's for someone, not necessarily the same person and do not include duplicates. In SQL, that looks like this, Select CurrentCity from RegularUser, Select HomeTown from RegularUser, intersects them while we turn a set. So, when you look here, which cities are going to be CurrentCity for someone and HomeTown for someone, not necessarily the same person, while Seattle will not because not HomeTown for anyone. Austin will because Austin appears here and it appears here and it appears here. So, Austin is going to be part of the result. San Diego is not,. San Francisco, yes, San Francisco is here and San Francisco is here so it's part of the result. College Park, no. Austin is all ready included in the result. So a set returned as before. If you want to see all cities as many times as they appear, then you say Intersect All. So, the only difference between the results here and the results here now is that Austin is counted twice. Why is that? Well, as you see here, Austin is the CurrentCity for two people and Austin is also the HomeTown for two people. So, that is why Austin appears twice in the Intersect All.

<h1>19 - Set Operations-Except</h1> Finally, set operator Except expressed in SQL. I want to find all cities that are CurrentCity's, but we want to exclude those that are HomeTown's. Again, we want to set return without duplicates. So, same deal, Select CurrentCity from RegUser. Select HomeTownfrom RegUser. Return the result of the first query except those that appear in the Result of the second query. So, let's look at what the result of this query is. So, Seattle is in the Result as you see up here because it's not a HomeTown for anyone. Las Vegas is in the Result. Same reason. San Diego is not in the Result because it's a HomeTown for User form. San Francisco is in the Result, it's not a HomeTown for any of these users. San Diego, is still not in it because it's a hometown. Las Vegas, already is in it and there are no duplicate returned. So, the result of this query in this table is here. Let's now take a look at what happens if we want to consider duplicates. So, the same way we did before instead of writing Except to return a Set, we now say Except All and the number of occurrences in the two operand intermediate results will now play a role in what comes back. So, Seattle as before, is in the Result. It's not a HomeTown for anyone. This Las Vegas is in the Result. It's not a HomeTown for anyone. San Diego is going to be in the result because San Diego appears here and here that's twice and it appears one time over here, 2 minus 1 is 1. So, San Diego is now in the Result. San Francisco is there for the same reason it was before. How about Las Vegas? Well, we already have Las Vegas here. It's not a HomeTown for anyone. So, the second time it appears here, it's also in the Result.

<h1>20 - Built in Functions</h1> To continue talking about functionality, which is very useful in real life databases, let's consider the concept of built-in functions. So, count, sum, average, minimum, and maximum are all examples of built-in functions. Let's take a look at one. Let's say, I want to count the number of RegularUser's. In other words, count how many RegularUser's there are. In SQL, that's written as follows, SELECT count everything from RegularUser. So, the semantics is as follows, we've got user 1, 2, 3, 4, 6, 8 and 9. That's a total of seven users. So, the result here is a table with a single column, and a single row, and the number seven in it reflecting that there are seven rows in the RegularUser table. Let's look at a second example, max. Let's say, we want to find Email and BirthYear for the youngest Female RegularUser. It would look like this. Find Email and max(BirthYear) from RegularUser where Sex equals Female. So, let's take a look here at BirthYear and let's find out what the max(BirthYear) is. See '85. '69? No. '67? No. '88 is younger than '85. '88, '68, '88. So, turns out that there are three users that have birth year '88. Two of those are females, user6 and user9. So, the result is user6 '88, user9 '88.

<h1>21 - Group By</h1> Sometimes, you would like to group the data that comes back from a query in groups and then apply some simple calculations within each group. Let's look an example. Let's say one of group user interests on email. Then let's say, that for each one of those groups, we want to return the corresponding email, the number of interest that user has together with the average SinceAge of those interests for that user. And then, maybe you want to sort of result by ascending number of interests. That query is expressed as follows. We want to select email and count(*). We want to return that count in our column which we give the name, NumInt for number of interests and, we want to return the average SinceAge in a column that we like to name average age. So, the result table will have an email attribute. It will have an attribute NumInt that contains the count, and it will have an average age attribute that returns the average age. So, let us then look at the result of the query. So, the group or user1s has three interests in it. So user1, three interests and then 10 plus five plus 14 divided by three gives you the average SinceAge for that user. Number two, there's one, two, three, four, five in the group. So, user2 has five interests and if you add the SinceAge up divided by five, that's the average age you get. Find user4 has a single interest and therefore of course the average age is 18. The order they come in is because we insisted that we sort the result on ascending number of interests. So that's what you see here, ascending number of interests and that's indicated here as you have seen before with the Order clause, Order By NumInt ascending. In the next example, you will see that it's actually possible to put conditions on the groups that you return data from.

<h1>22 - Having-Condition on the group</h1> So, let's say we are doing the exact same query, but we only want to return the groups that have more than one interest. The way we do that is that, in addition to the group by clause on email here, we have a condition on the group saying, "Having NumInt greater than one." Other than that, the query is exactly the same. If you look at the results here, you will also see the result is the same, except the user4, who had just a single interest does no longer appear in the result because of this clause.

<h1>23 - Not In</h1> The final SQL concept I want to introduce to you is the concept of nested queries. We are going to illustrate for you three different types of nested queries. So, let's look at a simple example. Let's find email and interests for RegularUser's in Atlanta. So, let's look at the UserInterests table. Consider first the first row, will then contribute to the result. Well it's user one and user one lives in Atlanta satisfying the nested query and therefore user one and music will contribute to the result. What about this one here? We already know user one lives in Atlanta. So, user one reading is in here, user one tennis is in here, what about user two? Well, user two does not have hometown Atlanta, so user two does not contribute to the result. Neither does user three who has hometown Portland or user four lives in Atlanta, so user four and DIY contributes to the result. You can think about it slightly differently. You could say, in this case here you would look at the inner query and say SELECT email FROM RegularUser WHERE HomeTown equals Atlanta. You're going to see, that only the user one and user four are going to count in this example. So, when you look at the outer query, you just need to check whether the email for which you are considering listing email and interest, whether that's in the result of the inner query consisting of user one and user four. You could say there's no correlation necessarily between the two which you are considering in the outer query and those you are looking at in the inner query. The inner query is the same we got this off which row you look at in the outer query. We'll see that differently in later examples, and alternative of course for this very very simple query is that you just take the UserInterests and RegularUser table represented by alias I and U, and you just join them on matching emails, select where hometown is Atlanta and then project on email and interest.

<h1>24 - All</h1> So, in this next type of nested queries, let's look at the following example. Find CurrentCitys with at least one RegularUser who has a Salary that's higher than all Salaries of RegularUsers with the HomeTown, Austin. Since the Salary column is in one table and the HomeTown is in another one, we obviously have to join the two tables together. What's the join attribute? It's BirthYear. So, let's join RegularUser and YearSalary together, call them R and Y, where the BirthYears match. Select from that where the HomeTown equals Austin and project from that the Salary. So, now, you're going to end up with the following salaries. User2 lives in Austin, user2 is born in 69, people born in 69 make 43,000. So, 43,000 is one of the Salaries for users in Austin. Another one is user12, born in 74, people born in 74 makes $38,000. So, now, you have two salaries; 43,000 and 38,000. Let's now get back to the query here. So, here, you have 38,000 and 43,000. So, the outer query now says select the CurrentCity from RegularUsers where the Salary that those RegularUsers make is greater than all of those that result from the sub query. So, in other words, the Salary is greater than 38 and 43. Again, since CurrentCity and Salary live in different tables, we got to join the two tables together in the outer query also. So, let's now consider whether the CurrentCity, Seattle, is in the result. Seattle is the CurrentCity of user1, born in 85, and those born in 85 make 27. Twenty seven is not greater than 38 and 43 so Seattle is not in the result. Is Austin in the result? Austin has user2 in it, born in 69, people born in 69 make 43. Is 43 greater than 38 and 43? The answer is no. Had it been greater than equal to, it would have been different. Therefore, Austin is not in the result. About San Diego, San Diego, user3, born in 67, salary for people born in 67 is 45. Is 45 greater than 38 and 43? Yes. So, is San Diego in the result? Yes, we just saw it is. But it certainly is not in the result because of user6. Because user6 is born in 88, those born in 88 make 24 and that's less than both 38 and 43. However, it still is in there because user3 was born in 67. Let's take a look at College Park. College Park, there's a person born in 68, people born in 68 earn 44,000. Forty four is greater than 43 and 38. Is College Park in the result? Well, yes it was. But it's not added to the result because of this person. User12 was born in 74, those born in 74 make 38. Thirty eight is not greater than 43 and 38. Of course, in all of these cases, when we went in and compared, we asked whether the salary of the user we are considering to return CurrentCity from was greater then 38 and 43. Why did we do that? We didn't have to compare to both 43 and 38. All we would have to do to make sure that salary is greater than all of them is to compare to the 43. So, instead of writing this comparison here, we could just have compared the salary to the biggest one of those returned by the inner query. In other words, we could have done it like this. So, the inner query instead would have been select the max(salary) here, that would have yielded the 43, and each one of these in the outer query would be compared just to the max query, 43.

<h1>25 - Nested Queries-correlated</h1> The last type of Nested Queries I want to show you is that of a correlated query. Say we want to find the Email and BirthYear of RegularUsers who have no Interests at all. The SQL query looks like this and I will explain it in just a second on the example but I want to do the following with you. In the two previous examples, when we read the inner query, we could think of first evaluating the inner query and then use the result of that when considering tupples to return in the outer query. That cannot be done in this case when queries are correlated. Let me show you why. So in this query we say, select everything from UserInterest, U where U.Email equals R.Email. What is R? R does not exist in this particular inner query. So where is R? This is called a reference out of scope. So the next layer up from this inner query is this layer. As you see, in the scope of this layer R is defined. So in other words from the inner query you have a reference to the outer query. These queries are quite different to understand. I'm going to go through a method that allows you to write and to understand those queries. The problem is that since the result of the inner query depends on the outer query, you're essentially looking at a situation where for every single possible instantiation of R of a RegularUser, there's a completely new query as the inner query. So think of it as a sub query being evaluated for every single instantiation of the topper variable R ranging over a regular user. That gives, of course, a clue as to how to write these queries and how to think about them. So let's simply proceed from the top here and ask the question. For the first row in RegularUser. So this user 1 '85 M is that can contribute to the result of the query. So the instantiation in the RegularUser of table of the tupple variable R is to the first row. Are we going to return Email and BirthYear from the first row? Well, let's take a look. For that first row, is it true that there does not exist anything in the result of this inner query? So the comparison here between the outer and the inner query is exist, not exist,. In this case, not exist. So, in other words, for that first row, will the result of the inner query result to the empty set. So look at the first instantiation of U in UserInterest. That's the user one row. Does that email match this email? Yes it does. It is not true that there does not exist anything in the restart of this query. Therefore, the first instantiation of R does not give an empty set of the inner query. So user one does not contribute. What about the second row here, user two. Is it the case that there is nothing on the UserInterest table with email user two? No. Doesn't contribute. User three? Doesn't contribute. Use four? Doesn't contribute. User six, wait a second now. Looking for users in UserInterest with Email user six, is that an empty result? Yes, it is. Because user six has no interest at all. Therefore, user six contributes to the result together with BirthYear '88. User eight, no interests contributes to the result. User nine, no interest contributes to the result. So that is the expression of finding the set of Emails and BirthYears for RegularUsers that have no Interests whatsoever.

