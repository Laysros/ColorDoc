<h1>13. Methodology IV_ Implementation </h1></br><h1>1 - Implementation</h1> We are now ready to look at the last phase of the database application development methodology, implementation. Let us review where we are. So, in design, we created a relational database schema and wrote the SQL for it. We also wrote the SQL for the tests that are going to access that relational schema. We surrounded that SQL with abstract code. In the implementation phase, we are again going to do data first. So, we start out with relational schema and we need to implement that on relational platform. We will install MySQL to run it on. After we have done that, we'll take a look at the abstract code that surrounds the SQL, we will implement that in PHP and we will show how to run that PHP script with the embedded SQL on the database we have set up.

<h1>2 - AMP solution stack</h1> Let me first briefly give you an overview of all the AMP stacks that out there. The basic idea is that all the client needs is a browser. That browser will talk with a server. On the server at the top level, you have an HTML server, underneath of that, you have a PHP server, and finally at the bottom, you have the database server.

<h1>3 - Implementation Data First</h1> As in all the previous phases, let's look at data first. Following this, you're going to see a number of WAMP stack demos. In the first one, you're going to learn how to install a WAMP stack. Once the WAMP stack is installed, it's ready to accept a database. In general, database management systems come with bulk load utilities. These utilities make it easy to load a lots database into a relational database management system. We're going to cheat a little bit in this case because we actually going to use a script to load the example GTOnline database in through a tool called phpMyadmin. That script is going to be available to you on the downloadable so you can use the same script to create the GTOnline database inside of the MySQL database that's part of your WAMP stack. I strongly encourage you to play around with the GTOnline database using the phpMyAdmin interface. It's a good way to familiarize yourselves better with SQL. You can play with insertions, you can play with queries, and once you need to clean up the example database, just go load it in using the script one more time.

<h1>4 - WAMP stack demos (headshot)</h1> Hello. I would like to introduce you to Will Johnson. Will Johnson is TA in our Database Class here. He is also an OMS CS student as you can see. He is going to tell you everything you need to know about how to install and run a WAMP stack.

<h1>5 - Install the WAMP Stack</h1> So what we're basically here for is to install the WAMP stack, which is the tool that we're going to use for doing the projects in this class. There are essentially three different AMP stacks. There's the WAMP stack, which is good for Windows. There's the MAMP stack, which is for Macintosh and the LAMP stack which is good for Linux. The LAMP stack is actually the oldest as I understand it, but we're going to work with the WAMP stack because we're on a Windows machine here. So these are the URLs that you will use. I've tried all three of them. They all seem to work very well. So you can use the one that's appropriate for you. I will say, if you're using the WAMP stack on Windows and you're on a machine that's still at XP, it isn't going to work for you because I tried. They don't support anything prior to Windows 7, I believe at this point. So start with the URL that you want which in this case is this one. We're going to go over to the browser and we're going to go to that location. The screen looks exactly the same whether you choose WAMP, LAMP or MAMP. It's the same format so you'll see the same thing. And what you'll do is over here, the latest version. Just click on it. I'm sure you all know how to download things. Click on "No thanks, just take me to download" and save the file or whatever's appropriate for your particular browser. So here's the file that we have downloaded and we're just going to execute it. Go through the standard install. Nothing special to achieve here. Put it where you want to put it. You know how this works. Now, this is the first thing that you need to be aware of. It's going to create a root account for you. The root account is what's going to have all of the access to the database so you need to pick a password you're going to use. Now try to begin installing. Installation has completed and it will launch forth automatically when I click "Finish."

<h1>6 - Run the WAMP Stack</h1> There are two different things that you see when you run the WAMP stack. The first thing is it brings you to this main page here but it also brings you this control panel. And the most important thing you're going to want here is the managed servers because there are two things that will be running on your machine and every once in a while you'll need to stop them or start them or make sure if you reboot your machine, "I don't know why one of the machines I installed this on it comes up and automatically starts. The other one I installed it on when I was playing comes up and doesn't automatically start," So you have to start this up and then click "Start All" and "My SQL" and the Web server will start. And then you can go over to here and say "Open my phpMyAdmin" and this is where you need that password that we had before. So again we use GATECH. You can use whatever you use and that brings us into the M"y phpAdmin" main screen. This is a web-based utility. It's essentially if you have used any other databases, if you've used PostgreSQL, this is similar to the pgAdmin program. If you've used Oracle, it's similar to a number of different utilities that they have. It basically shows us everything we have here. So if I click on "Databases", by default it has a few things that get loaded. The next thing we're going to do is we are going to install the sample database for the class that we are working on here. We have this SQL script that we're going to use and I'm going to do it through. You can run this at the command line but we're going to do it through the gooey just to show you some of the usefulness of the gooey. So basically, this is the script and I'm just going to cut it and paste it into the query window for phpMyAdmin. As you can see guys, I've posted this in here it has already formatted. Apparently, it did that on this one. When I did it on my computer, it didn't automatically format. You can press the Format button if it looks really funny and it will become something more human-readable. If you're not familiar with databases, this will look like Greek to you. By the time we're done, you'll understand what all this is but it just creates table scripts and puts in some initial rows and stuff so we're just going to run that query and it's going to run and when it's done, it tells us "That returned an empty result set." The reason it says "I returned an empty result set," is we didn't do any queries. There is DML and there's DDL. DML is data manipulation language. DDL is data definition language. That's things like creating tables, inserting rows, that sort of thing. This has all been DDL. There's no result sets coming back because we haven't asked for anything. But if we go back over here to the databases tab, you will see that now our DDL online complete database exists and we can click on it and go in and see all the tables that we have just created. Let us choose user and we can click browse and we can see what's in there. So this is basically just showing what's in the table and we can do the same thing by going to the SQL window and they've even showed us the query that they used. I don't know why they have to wear one that's not necessary but we could do the same thing here and just type go and we get the same results back. So now we're going to look at the regular user table and again we're going to browse which shows us what's in that table. It's got some different different columns in it and if we go to the structure tab, we can actually see what the different columns are in the structure of the database. So this one has the primary key. This shows us the primary key is the email address which is a very lengthy character up to 250 characters long. So the collation field has something to do with which character set is supported. This is non-nullable field. To have a row in the table, you must have something in this field as opposed to down here where it is nullable. You can enter something and not put in a current city or a home town. There is no default value for these three so again you have to specify them when you add a row. You don't have to specify these two because they have a default value defined. So we could define a default value that says "Hello" as the default value and save that. And now if we go back to the structure, we can see that the default value for current city is hello.

<h1>7 - Demo 03</h1> We already looked at select, and we looked at select with the WHERE equals one. Now, if you want to go back, and you can see there are two students with Los Angeles. So, if we were to say, WHERE current city equals Los Angeles, and run. Now, we get just those two rows back. So, that pretty much covers it. The basics of phpMyAdmin. There are some more tools in here, but a lot of what we're going to want to do in the class is going to be more script-based. So, we're learning how to do things rather than doing them through the gooey. So, that you do it and good luck.

<h1>8 - To Index or Not Many Things to Consider</h1> The last thing to consider in the data first portion of the implementation phase is whether we need to index any tables or not. First, I'll show you how to compute the size of a table. Second, a single table can be in the access paths of multiple queries and updates. Third, the relative frequencies or reads and or writes will affect our decision of whether to index or not. Next, it could be that the table is already appropriately indexed. Some database management systems like MySQL, don't give you a choice. Sometimes that's good, sometimes it's bad. Finally, I'm going to give you some general advice of when to index and when not to.

<h1>9 - To Index or Not Size of Table</h1> First, let's consider the size of the table. So, I'm using the example here of RegularUser, and these are some of the attributes. So, we have an Email which is a varchar(50), we have Sex which is a char(1), Birthdate is a datetime type. CurrentCity and Hometown are both varchar(50)s. So, the size of a record in this table is 50 times 3 is a 150, eight for datetime and one for Sex. So, that gives you a grand total of 159 bytes as record size. Second, let's assume our block size is 4k. Different database management systems come with different defaults. For highly formatted data, a lower block size is often used. If you have large objects and tables, then normally a higher block size is used. Also, we typically do not fill all blocks completely because it's going to cost a lot of overflow when we insert. Typical fill is somewhere between two-thirds, 80% is probably a fairly high number, but let's assume 80% here. Now, since the block size is 4k and since it's 80% full, which is 3.2k, divide that by a 160, and you end up with an approximate number of 20 records per block in this organization. Let's say that we got 4 million regular users, so the number of records is 4 million. What does that mean? Well, if we can fit 20 records per block and we got four million, that means that we'll have approximately 200,000 blocks to store the RegularUser table. That also means the total table size is going to be 800 megabytes, approximately. So, 800 megabytes may not sound like much. Some computers come with a main memory that is larger than that. But remember, this is only one table in the database; there may be many, many tables in the database. So, no one says that we are going to have the luxury of always keeping this table in memory. So, in general, you need to consider that major parts of tables are stored on disk and need to be brought up. So, even in this case here, where we only have 200,000 blocks in the RegularUser table, if we make the assumption that a page fault on the average is going to take a hundredths of a second, then to scan 200,000 blocks is going to cost you 200,000 times one hundredths of a second. That's about 33 minutes to scan the block if it's not clustered and/or indexed appropriately.

<h1>10 - To Index or Not Multiple Access Paths add up</h1> Now, addressing the issue that multiple access paths really add up is done also by the RegularUser example. So, if you recall back to previous phases of the methodology, there was a pending request from you for someone to be friends, that accesses the RegularUser table. There was also a pending request to you that accesses the RegularUser table. Then, there is the View Profile test which is just a retest and that accesses the RegularUser table. Then, of course, there was an Edit Profile test that updates the regular use information. So, all of these different queries, insertions, deletions to updates and so on, they all affect RegularUser. We need to know the frequencies of each one of these to see what the weight of access on RegularUser is from an overall point of view, and to help guide us as to whether we therefore need additional indexing of RegularUser.

<h1>11 - To Index or Not Reads and or Writes</h1> Most tables will be read from by some of the tests and written to by some tests. So, here's an example here again, continuing to use RegularUser. So, in View Profile we do a selection, that's a read from RegularUser. In Edit Profile of RegularUser, we clearly are updating, thus, writing back to the database the new state of that RegularUser we are updating and here, we actually, initially do an insertion of RegularUser into the RegularUser table. So, you see here reading, writing, and writing. In general, reads are faster if a table is indexed. If there are multiple indices on a table, however, then writing is slow because not only will we have to write the updated data or insert the data in the table, but we are also going to have to maintain any additional indices that are defined on that table. On the other hand, many writes will require that we first find what we need to write. So, for example, in an update we are clearly first identifying and finding the RegularUser tuple that needs to be updated, and then we are updating it. So, although writes are slower, if we don't have an index to find what we need to write fast, then we are in trouble. Of course, in insertion there is nothing to find because it's a new tuple. But what if we need to find the proper place to insert it in some order table? So, we're having a mixture of reads and writes will make it more complicated to decide whether additional indices are needed on the table or not.

<h1>12 - To Index or Not Already Indexed</h1> Sometimes tables are already indexed by the database management system. This is actually the case for the regular user the same way we have looked at. So, all the JOINs on that table and the look ups are on email. Email is the primary key of the table. When you're using MySQL, that table will actually already be clustered on or indexed on email. Therefore, the issues we've been discussing for regular user actually are non-issues when MySQL is used. In some cases, database management systems support that, in other case they do not. Sometimes it's good, sometimes it's bad.

<h1>13 - To Index or Not Some Advice</h1> So, let me now give you some general advice to summarize our discussion of these issues. First of all, pay attention to size. Even for relatively small table, you might not be able to keep it in memory at all times and you might need to index it to get to [inaudible]. Multiple queries add up. You need to consider all the different ways in which a particular table is accessed. In general, writes will suffer inefficiency when you index a table. However, in most cases, the write is preceded by a read, which benefits from an index on the table. There are some neat tools that many database management systems come with. One valuable tool is a tool to measure performance. Some database systems are able to print out for you the actual query graph that's used to execute a query. Very valuable to help you understand whether you need to further index that table or not, to force the use of a better query graph. I recommend that you think globally but you act locally. So, make small changes and when you have made small changes, compare the performance before the change to the performance after the change. If you want to know in more details what you're doing, you actually need to learn more about efficiency, more about physical database organization, and more about query optimization.

<h1>14 - Implementation Tasks</h1> Now that we have addressed data first in the implementation phase, let's take a look at the tasks. Following this, you going to see demos that show you how to run PHP scripts that implement a couple of the tasks in the DT online example. The scripts for doing that, again, are available on the downloadables. I strongly encourage you to check out the scripts to see how the input and output documents are written in the script, and how the scripts interact with the database.

<h1>15 - Run PHP Scripts for GTOnline example</h1> Let me show you how I can run PHP Scripts for some of the tasks in the GT Online example that we have discussed in class. By now, all of us should have either vamp, mamp or lamp stack installed on our local machines. Let us first head to the php my admin page which contains the GTOnline complete database with the tables installed a regular user, user, and friendship which we'll be focusing on in this demo. Now to run PHP scripts, we need to have a local host server running on our machines. For that, I'll next head to the domain lan, the MacBook. For Windows users, you need to go to the command prompt and type run. The command to start the php local host server is php -S localhost: and port number. The port number can be anything, you just need to remember the port number that we have entered and my local host server has been started on the same folder which contains all my PHP Scripts. So gtpe, underscore db, underscore course is the same folder which contains all the PHP scripts that I'm going to run in this demo. Next, I head to the browser and I will first show you the log in page which is the first page in the application. To access the log in page, you need to type localhost:8000. The port number again should be the same port number that we gave by starting the local host server; /login.php and this takes me to the application login page. Now I need to enter the login credentials of a particular user to get into the application. I'll head back to the php my admin page to pick up the details of one particular user. I'll go to the user table and I'll select Michael Bluth for example. I will just copy his email address and remember his password. Heading back to the log in page, I entered the details which were already entered in the database and try logging in. I've been successfully able to log into the user page and I can currently view the profile of Michael Bluth. Now the view profile is also another php page which is running in the background that was accessed from the login.php page. So next I can do a few tasks on this page like viewing the profile, editing the profile, viewing the friends of the user, etc. Let's try making a few changes to the already existing profile of Michael Bluth. For that, I need to go to the edit profile page. Let's quickly head back to the php my admin page and verify the details that are currently existing on that log in page. So it says the date of birth is 1st January, 1971 and the current city is New York. So if I head back to the php my admin page and I go back to the regular user table, I can find out that Michael Bluth's date of birth is 1st January, 1971 and his current city is New York. So if I go back to the edit profile page and change his current city from New York to San Francisco, next I click "Save". Next, let's see if these changes that we've made have been reflected in the database or not. If you go back to the php my admin page and refresh the page, you can see that the user Michael Bluth, his city, his current city has been updated to San Francisco. Exactly what we did on the application. Similarly, we can also view friends of Michael Bluth and these are the same that I again listed on the database.

<h1>16 - HTML demo</h1> Now that I've shown you how to use BHB scripts on the web browser, let us take a look what's inside a few of them now. I'll take you to the login.php page which was a first page on the application. So here is the page. The first step in the php page is to connect to the database using three credentials. The first is the host, the host name should be correct. Next is the user and the password. The user and the password is the same which we enter while creating the database on the mamp or lamp stack. Next we select the database GT online complete which is the database we are focusing on. We need to enter the details of the email ID and the password of the user as our first step. And since we're requesting data back from the web browser, this is a post request which is mentioned in this php code. Also you'll notice that every step, we have error statements to help you debug in case something goes wrong. Next the page requests the user to enter the email and password. Once we have entered the email and password, it gets stored in these two files. Next, the query which runs in the background to retrieve the user, the details of the user, is the query as follows: select "Start" from user, the email is that username that entered and password is the password that I can enter. Now once this query runs in the background, it returns me a result set. Next I check the number of rows in the result side is equal to zero. That means I have not been returned any user from the web application. That means the log in has failed or no such user exists. So if all such things go smoothly and I'm able to successfully log in, the session starts and the session is what, which will be active till the user logs out. Next, I'm redirected to the profile.php page which is done by the header. The rest part of the script includes HTML. HTML is what we see in the front end of the application. This HTML code uses the php script that I explain to you just know.

