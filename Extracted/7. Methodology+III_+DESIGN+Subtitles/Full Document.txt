<h1>7. Methodology III_ DESIGN </h1></br><h1>1 - Design</h1> As a result of the specification phase of the database application development methodology, we generated an extended entity-relationship diagram together with a set of test decompositions and associated abstract code specifying what the test would do relative to the extended entity-relationship diagram. Our next phase of the methodology is the design phase. In the design phase, we first concentrate on data and take the extended entity-relationship diagram and translate that into a relational schema. We then take the abstract code for the tasks and translate that into abstract code with embedded SQL that will do to the relational schema what the tests was specified to do through the extended entity-relationship diagram. In order to understand that first step of the design phase, we have taken a detour to find out enough about relations and enough about the mapping of the extended entity-relationship model to relations that we'd be able to carry out that step.

<h1>2 - EER Diagram Review 1</h1> So, here's the extended entity relationship diagram we ended up with. Just in review, we have a set of users. Users are uniquely identified by their Email, and in addition to that property type, it has property type of Password and Name which is composite consisting of First and LastName. Users have two subsets: RegularUsers and AdminUsers. The two subsets are disjoint. In other words, extensions often cannot overlap. Each one of these subsets of course will inherit the properties of the supertype, so RegularUser will inherit Email, Password, and Name, and so will AdminUser. AdminUser in addition has a property type LastLogin whereas RegularUser has a number of property types: Sex, Birthdate, CurrentCity, and HomeTown, and then a multi-valued property type Interests. RegularUsers also are connected to the many Schools that may have attended, and each one of these Schools will have a SchoolType. RegularUsers also have worked for a number of Employers. They may have worked for the same Employer several times, each time with a different JobTitle. Employers are uniquely identified by the EmployerName, as Schools are uniquely identified by SchoolName. Friendships may be requested and may be accepted. So, a RegularUser can request a Friendship with an other RegularUser. That other RegularUser in turn may accept that Friendship. For a particular RegularUser, of course, they will be a set of Friendships that that RegularUser has requested along with a set of Friendship that that RegularUser has accepted to enter into. So, our job now is to take this extended entity relationship diagram and translate it into a relational database. We will do that a little step at a time.

<h1>3 - EER Diagram Review 2</h1> Now, let us concentrate on mapping the portion of the entity relationship diagram that tie regular users to the schools they attended and to the employers that they were employed by. Let us start here at the bottom. The entity type, SchoolType, results in a relation with a single property type namely TypeName, which is the identifying property type of that relation. So, therefore, TypeName in essence will have values that is just a listing of the different kinds of types like high school, middle school, elementary school, etc. The School entity type has identified property type SchoolName. For that entity type, there'll be a relation school, it has SchoolName as a property type, it's the primary key, and then it has type as an additional property because it is the many site of a one to many relationship that many site can point to the SchoolType. So, the type you see here is basically a foreign key pointing to the primary key of school type. The attend relationship type is many-to-many relationship type as you can see. In order to map many-to-many relationship types, we need the identifying property type of each one of the participating entity types. So, we need Email to identify RegularUser and we need SchoolName to identify the School. So, therefore, it's no surprise that for the attend many-to-many relationship type, we will have both the Email and the SchoolName included. What is a little bit different about this mapping is that for each one of these instances, there is a YearGraduated associated with it. One reason for that could be that you might attend, for example, Georgia Tech twice, once for your bachelor's and one for your master's. For each one of those, there will, of course, be a unique YearGraduated. How do we model a multivalue like this? Well, it's a multivalue of that relationship type, so we would need the identifier for the relationship type, which is a combination of these two. We can collapse that mapping all-in-all into a single relation call Attend that has both the School identifier of SchooName, the RegularUser identifier of Email, and then YearGraduated, all of those combined as unique. The employment relationship type is also a many-to-many relationship type, so it will result in a relation called employment that will have the Email of the RegularUser employed, the EmployerName of the Employer, and as before, an attribute for the JobTitle, which is multivalue. So, this is very similar in nature to the relation we just generated here. So, Employment will have Email, EmployerName, and JobTitle as unique. Noticed that for this unique or for this key, SchoolName is a foreign key on SchoolName of School. For this unique key, EmployerName is a foreign key pointing to the primary key EmployerName for the employer relation. Notice that I have indicated the RegularUser table here, although we have previously dealt with that. The reason is that the RegularUser who participates in the Attend relationship and the Employment relationship, those are users who have emails that of course, appear in the RegularUser Email list. So, therefore, Email of Attend and Email of Employment are foreign keys on Email in RegularUser.

<h1>4 - Mapping the Super Subtype v2</h1> Let's first concentrate on the mapping of the super sub type relationship that connects users to regular users and admin users. There were a couple of options in the mapping, we have chosen the option where we create a relation for each one of the entity types. So, for the first entity type user, we create the relation user it has identifying property type email and that therefore becomes the primary key of the user relation. In addition, it has property types password and it has property types first name and last name. Unfortunately as you recall, composite property types are not preserved in the mapping. User has two sub types; regular user and admin user, both of those will inherit email password, first name and last name. However, in the mapping of each one of these entity types the only one of these that will appear is the identifying property type email which will become the primary key in the admin user relation and in the regular user relation. In the admin user relation, we have in addition the last log in and in the regular user relation we have an additional four properties namely; sex, birth date, current city and hometown as reflected here. As you recall, multi value property types, each one of those, will get its separate relation together with the identifying property type for that entity type. So, for the interest property type a separate relation will be generated and that relation will have the combination of email and interest as primary key. You see here that email of admin user in addition to being primary key also is a foreign key pointing back to the user relation. In other words, it's not possible to have an admin user who is not also a user. Similarly for the regular users, the email primary key of regular user is also a foreign key pointing back to email end user. Finally, interests are properties of regular users, therefore email which is part of the primary key of interest, email will be a foreign key pointing back to email of the regular user.

<h1>5 - Weak Entity Type Mapping</h1> Finally, let's look at the mapping of the week entity type friendship. This is a fairly complex situation. So you have a strong entity type regular user and a weak entity type friendship and there's an identification relationship type between them. So in other words in order to identify friendship you're going to need the identifier for regular user. But wait, there's one more of those involved. So in order to understand a friendship you need to know not just the regular user that requested it but also the regular user who has been asked to accept it. So when looking at the friendship relationship type it will have email twice. It will have email of the one making the request and email of the friend that the request is being made to. Then there are two property types relationship and date connected and date connected is going to initially be null and then subsequently if the one invited to become friends accepts it will be set to the date of that accept. Again I've included this one in order to show that both the email of the requester and the potential acceptor of the friendship is going to be an email of a regular user since only regular users can participate in these friendships. An interesting aside about this friendship relation is the following. Notice that there are two one to many relationships into friendship and typically when we have a many to many relationship type that can actually be modeled by two one to many relationships into the same entity type. When that's the case, then the combination is a key. That corresponds very much to other cases we've seen of many to many relationship types where you take a key from each end of the relationship.

<h1>6 - Relational Schema</h1> So here's a summary of the whole thing. This is the schema we have mapped and this is a summary of what I showed you before. So our relational schema is now this one, represented in graphical form with all the primary keys, all the keys, and all the foreign key relationship types. It is important that each one of these relations is in the proper normal form.

<h1>7 - DETOUR_ NORMALIZATION</h1> Before we go any further, we need a small detour to study an additional database tool or technique

